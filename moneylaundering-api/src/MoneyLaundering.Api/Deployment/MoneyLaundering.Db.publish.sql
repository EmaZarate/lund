/*
Deployment script for MoneyLaundering

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "MoneyLaundering"
:setvar DefaultFilePrefix "MoneyLaundering"
:setvar DefaultDataPath "C:\Users\ezarate\AppData\Local\Microsoft\Microsoft SQL Server Local DB\Instances\mssqllocaldb\"
:setvar DefaultLogPath "C:\Users\ezarate\AppData\Local\Microsoft\Microsoft SQL Server Local DB\Instances\mssqllocaldb\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS ON,
                ANSI_PADDING ON,
                ANSI_WARNINGS ON,
                ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                QUOTED_IDENTIFIER ON,
                ANSI_NULL_DEFAULT ON,
                CURSOR_DEFAULT LOCAL 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET PAGE_VERIFY NONE 
            WITH ROLLBACK IMMEDIATE;
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET TARGET_RECOVERY_TIME = 0 SECONDS 
    WITH ROLLBACK IMMEDIATE;


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE (QUERY_CAPTURE_MODE = AUTO, OPERATION_MODE = READ_WRITE) 
            WITH ROLLBACK IMMEDIATE;
    END


GO
PRINT N'Rename refactoring operation with key 9365d329-d0bb-493b-a296-8bd8d4840c49 is skipped, element [dbo].[FinancialProfilesDefaultLog].[FinantialProfile] (SqlSimpleColumn) will not be renamed to FinancialProfile';


GO
PRINT N'Rename refactoring operation with key 030707a2-5d9f-4367-8d3a-c6dc9582d009 is skipped, element [dbo].[PersonBusinessUnit].[FinatialProfile] (SqlSimpleColumn) will not be renamed to FinancialProfile';


GO
PRINT N'Rename refactoring operation with key b469e449-83fe-4bbd-8c29-97f73dbe08c5 is skipped, element [dbo].[DocumentVersion].[DocumentVersionTypeId] (SqlSimpleColumn) will not be renamed to DocumentVersionId';


GO
PRINT N'Creating [fwk]...';


GO
CREATE USER [fwk] WITHOUT LOGIN
    WITH DEFAULT_SCHEMA = [fwk];


GO
REVOKE CONNECT TO [fwk];


GO
PRINT N'Creating [fwk]...';


GO
CREATE SCHEMA [fwk]
    AUTHORIZATION [fwk];


GO
PRINT N'Creating [fwk].[Table]...';


GO
CREATE TABLE [fwk].[Table] (
    [TableId]               INT           IDENTITY (1, 1) NOT NULL,
    [Name]                  VARCHAR (100) NOT NULL,
    [Token]                 VARCHAR (200) NOT NULL,
    [Schema]                VARCHAR (10)  NOT NULL,
    [HasAudit]              BIT           NOT NULL,
    [IsSystemData]          BIT           NOT NULL,
    [IsAdministeringByUser] BIT           NOT NULL,
    [HasSystemRecords]      BIT           NOT NULL,
    [IsParameterData]       BIT           NOT NULL,
    [IsTransactionData]     BIT           NOT NULL,
    [NotDeleteTrigger]      BIT           NOT NULL,
    [NotUpdateTrigger]      BIT           NOT NULL,
    [NotAuditField]         BIT           NOT NULL,
    [HasInsertAudit]        BIT           NOT NULL,
    [HasUpdateAudit]        BIT           NOT NULL,
    [HasDeleteAudit]        BIT           NOT NULL,
    CONSTRAINT [PK_fwk_Table] PRIMARY KEY CLUSTERED ([TableId] ASC),
    CONSTRAINT [UK01_fwk_Table] UNIQUE NONCLUSTERED ([Name] ASC),
    CONSTRAINT [UK02_fwk_Table] UNIQUE NONCLUSTERED ([Token] ASC)
);


GO
PRINT N'Creating [dbo].[Activity]...';


GO
CREATE TABLE [dbo].[Activity] (
    [ActivityId]       INT           IDENTITY (1, 1) NOT NULL,
    [Description]      VARCHAR (200) NOT NULL,
    [ObligatedSubject] BIT           NULL,
    CONSTRAINT [PK_Activity] PRIMARY KEY CLUSTERED ([ActivityId] ASC)
);


GO
PRINT N'Creating [dbo].[ActivityRisk]...';


GO
CREATE TABLE [dbo].[ActivityRisk] (
    [ActivityRiskId] INT      IDENTITY (1, 1) NOT NULL,
    [BusinessUnitId] INT      NOT NULL,
    [ActivityId]     INT      NOT NULL,
    [RiskPH]         SMALLINT NULL,
    [RiskPJ]         SMALLINT NULL,
    CONSTRAINT [PK_ActivityRisk] PRIMARY KEY CLUSTERED ([ActivityRiskId] ASC)
);


GO
PRINT N'Creating [dbo].[Antiquity]...';


GO
CREATE TABLE [dbo].[Antiquity] (
    [AntiquityId]    INT      IDENTITY (1, 1) NOT NULL,
    [BusinessUnitId] INT      NOT NULL,
    [RiskHighTo]     SMALLINT NOT NULL,
    [RiskMediumTo]   SMALLINT NOT NULL,
    CONSTRAINT [PK_Antiquity] PRIMARY KEY CLUSTERED ([AntiquityId] ASC)
);


GO
PRINT N'Creating [dbo].[Branch]...';


GO
CREATE TABLE [dbo].[Branch] (
    [BranchId]    INT           IDENTITY (1, 1) NOT NULL,
    [Description] VARCHAR (100) NOT NULL,
    CONSTRAINT [PK_Branch] PRIMARY KEY CLUSTERED ([BranchId] ASC)
);


GO
PRINT N'Creating [dbo].[BranchOffice]...';


GO
CREATE TABLE [dbo].[BranchOffice] (
    [BranchOfficeId] INT           IDENTITY (1, 1) NOT NULL,
    [Description]    VARCHAR (200) NOT NULL,
    [Mail]           VARCHAR (200) NULL,
    [Address]        VARCHAR (500) NULL,
    [StateId]        INT           NULL,
    [CountryId]      INT           NULL,
    [ZipCode]        INT           NULL,
    CONSTRAINT [PK_BranchOffice] PRIMARY KEY CLUSTERED ([BranchOfficeId] ASC)
);


GO
PRINT N'Creating [dbo].[BusinessUnit]...';


GO
CREATE TABLE [dbo].[BusinessUnit] (
    [BusinessUnitId] INT           IDENTITY (1, 1) NOT NULL,
    [Description]    VARCHAR (200) NOT NULL,
    CONSTRAINT [PK_BusinessUnit] PRIMARY KEY CLUSTERED ([BusinessUnitId] ASC)
);


GO
PRINT N'Creating [dbo].[CaseDocument]...';


GO
CREATE TABLE [dbo].[CaseDocument] (
    [CaseDocumentId] INT IDENTITY (1, 1) NOT NULL,
    [CaseId]         INT NOT NULL,
    [DocumentId]     INT NOT NULL,
    [BusinessUnitId] INT NOT NULL,
    CONSTRAINT [PK_CaseDocument] PRIMARY KEY CLUSTERED ([CaseDocumentId] ASC)
);


GO
PRINT N'Creating [dbo].[CaseGroup]...';


GO
CREATE TABLE [dbo].[CaseGroup] (
    [CaseGroupId] INT           IDENTITY (1, 1) NOT NULL,
    [Description] VARCHAR (200) NOT NULL,
    CONSTRAINT [PK_CaseGroup] PRIMARY KEY CLUSTERED ([CaseGroupId] ASC)
);


GO
PRINT N'Creating [dbo].[CaseType]...';


GO
CREATE TABLE [dbo].[CaseType] (
    [CaseTypeId]  INT           IDENTITY (1, 1) NOT NULL,
    [Description] VARCHAR (200) NOT NULL,
    [CaseGroupId] INT           NULL,
    CONSTRAINT [PK_CaseType] PRIMARY KEY CLUSTERED ([CaseTypeId] ASC)
);


GO
PRINT N'Creating [dbo].[CaseVehicle]...';


GO
CREATE TABLE [dbo].[CaseVehicle] (
    [CaseVehicleId]  INT          IDENTITY (1, 1) NOT NULL,
    [BusinessUnitId] INT          NOT NULL,
    [CaseId]         INT          NOT NULL,
    [LicensePlate]   VARCHAR (50) NOT NULL,
    CONSTRAINT [PK_CaseVehicle] PRIMARY KEY CLUSTERED ([CaseVehicleId] ASC)
);


GO
PRINT N'Creating [dbo].[CategoryCost]...';


GO
CREATE TABLE [dbo].[CategoryCost] (
    [CategoryCostId] INT           IDENTITY (1, 1) NOT NULL,
    [Description]    VARCHAR (150) NOT NULL,
    CONSTRAINT [PK_CategoryCost] PRIMARY KEY CLUSTERED ([CategoryCostId] ASC)
);


GO
PRINT N'Creating [dbo].[Channel]...';


GO
CREATE TABLE [dbo].[Channel] (
    [ChannelId]   INT           IDENTITY (1, 1) NOT NULL,
    [Description] VARCHAR (200) NOT NULL,
    CONSTRAINT [PK_Channel] PRIMARY KEY CLUSTERED ([ChannelId] ASC)
);


GO
PRINT N'Creating [dbo].[ChannelRisk]...';


GO
CREATE TABLE [dbo].[ChannelRisk] (
    [ChannelRiskId]  INT IDENTITY (1, 1) NOT NULL,
    [BusinessUnitId] INT NOT NULL,
    [ChannelId]      INT NOT NULL,
    [RiskId]         INT NULL,
    CONSTRAINT [PK_ChannelRisk] PRIMARY KEY CLUSTERED ([ChannelRiskId] ASC)
);


GO
PRINT N'Creating [dbo].[Country]...';


GO
CREATE TABLE [dbo].[Country] (
    [CountryId]   INT           IDENTITY (1, 1) NOT NULL,
    [Description] VARCHAR (200) NOT NULL,
    CONSTRAINT [PK_Country] PRIMARY KEY CLUSTERED ([CountryId] ASC)
);


GO
PRINT N'Creating [dbo].[CoverageType]...';


GO
CREATE TABLE [dbo].[CoverageType] (
    [CoverageTypeId] INT           IDENTITY (1, 1) NOT NULL,
    [Description]    VARCHAR (200) NOT NULL,
    CONSTRAINT [PK_CoverageType] PRIMARY KEY CLUSTERED ([CoverageTypeId] ASC)
);


GO
PRINT N'Creating [dbo].[Document]...';


GO
CREATE TABLE [dbo].[Document] (
    [DocumentId]      INT           IDENTITY (1, 1) NOT NULL,
    [PersonId]        INT           NOT NULL,
    [PersonOrignalId] INT           NULL,
    [LogicName]       VARCHAR (500) NOT NULL,
    [DocumentTypeId]  INT           NOT NULL,
    [Confidential]    BIT           NOT NULL,
    CONSTRAINT [PK_Document] PRIMARY KEY CLUSTERED ([DocumentId] ASC)
);


GO
PRINT N'Creating [dbo].[DocumentLetterType]...';


GO
CREATE TABLE [dbo].[DocumentLetterType] (
    [DocumentLetterTypeId] INT           IDENTITY (1, 1) NOT NULL,
    [Description]          VARCHAR (300) NULL,
    CONSTRAINT [PK_DocumentLetterType] PRIMARY KEY CLUSTERED ([DocumentLetterTypeId] ASC)
);


GO
PRINT N'Creating [dbo].[DocumentType]...';


GO
CREATE TABLE [dbo].[DocumentType] (
    [DocumentTypeId] INT           IDENTITY (1, 1) NOT NULL,
    [Description]    VARCHAR (200) NOT NULL,
    CONSTRAINT [PK_DocumentType] PRIMARY KEY CLUSTERED ([DocumentTypeId] ASC)
);


GO
PRINT N'Creating [dbo].[DocumentVersion]...';


GO
CREATE TABLE [dbo].[DocumentVersion] (
    [DocumentVersionId] INT           IDENTITY (1, 1) NOT NULL,
    [DocumentId]        INT           NOT NULL,
    [VersionId]         INT           NOT NULL,
    [PhysicalName]      VARCHAR (500) NOT NULL,
    [CreateDate]        DATETIME2 (7) NOT NULL,
    [Comment]           TEXT          NULL,
    [Expiration]        DATETIME2 (7) NULL,
    CONSTRAINT [PK_DocumentVersion] PRIMARY KEY CLUSTERED ([DocumentVersionId] ASC)
);


GO
PRINT N'Creating [dbo].[FinancialProfilesDefault]...';


GO
CREATE TABLE [dbo].[FinancialProfilesDefault] (
    [FinancialProfilesDefaultId] INT      IDENTITY (1, 1) NOT NULL,
    [BusinessUnitId]             INT      NOT NULL,
    [PersonType]                 CHAR (1) NOT NULL,
    [RiskType]                   SMALLINT NOT NULL,
    [FinancialProfile]           INT      NOT NULL,
    CONSTRAINT [PK_FinancialProfilesDefault] PRIMARY KEY CLUSTERED ([FinancialProfilesDefaultId] ASC)
);


GO
PRINT N'Creating [dbo].[FinancialProfilesDefaultLog]...';


GO
CREATE TABLE [dbo].[FinancialProfilesDefaultLog] (
    [FinancialProfilesDefaultLogId] INT           IDENTITY (1, 1) NOT NULL,
    [BusinessUnitId]                INT           NOT NULL,
    [PersonType]                    CHAR (1)      NOT NULL,
    [RiskType]                      SMALLINT      NOT NULL,
    [FinancialProfile]              INT           NOT NULL,
    [Audit_Insert_User]             VARCHAR (50)  NOT NULL,
    [Audit_Insert_Date]             DATETIME2 (7) NOT NULL,
    [Audit_Update_User]             DATETIME2 (7) NOT NULL,
    [Audit_Update_Date]             VARCHAR (50)  NOT NULL,
    CONSTRAINT [PK_FinancialProfilesDefaultLog] PRIMARY KEY CLUSTERED ([FinancialProfilesDefaultLogId] ASC)
);


GO
PRINT N'Creating [dbo].[GrayList]...';


GO
CREATE TABLE [dbo].[GrayList] (
    [GrayListId]       INT  IDENTITY (1, 1) NOT NULL,
    [Comments]         TEXT NULL,
    [Active]           BIT  NOT NULL,
    [PersonId]         INT  NULL,
    [PersonOriginalId] INT  NULL,
    CONSTRAINT [PK_GrayList] PRIMARY KEY CLUSTERED ([GrayListId] ASC)
);


GO
PRINT N'Creating [dbo].[GrayListDocument]...';


GO
CREATE TABLE [dbo].[GrayListDocument] (
    [GrayListDocumentId] INT IDENTITY (1, 1) NOT NULL,
    [DocumentId]         INT NOT NULL,
    [GrayListId]         INT NOT NULL,
    CONSTRAINT [PK_GrayListDocument] PRIMARY KEY CLUSTERED ([GrayListDocumentId] ASC)
);


GO
PRINT N'Creating [dbo].[LimitAccumulatedClaimsCharged]...';


GO
CREATE TABLE [dbo].[LimitAccumulatedClaimsCharged] (
    [LimitAccumulatedClaimsChargedId] INT      IDENTITY (1, 1) NOT NULL,
    [BusinessUnitId]                  INT      NOT NULL,
    [PersonType]                      CHAR (1) NOT NULL,
    [RiskType]                        SMALLINT NOT NULL,
    [Limit]                           INT      NOT NULL,
    CONSTRAINT [PK_LimitAccumulatedClaimsCharged] PRIMARY KEY CLUSTERED ([LimitAccumulatedClaimsChargedId] ASC)
);


GO
PRINT N'Creating [dbo].[LimitAccumulatedPremium]...';


GO
CREATE TABLE [dbo].[LimitAccumulatedPremium] (
    [LimitAccumulatedPremiumId] INT        IDENTITY (1, 1) NOT NULL,
    [BusinessUnitId]            INT        NOT NULL,
    [PersonType]                CHAR (1)   NOT NULL,
    [RiskType]                  SMALLINT   NOT NULL,
    [Limit]                     FLOAT (53) NULL,
    CONSTRAINT [PK_LimitAccumulatedPremium] PRIMARY KEY CLUSTERED ([LimitAccumulatedPremiumId] ASC)
);


GO
PRINT N'Creating [dbo].[LimitAssuredSum]...';


GO
CREATE TABLE [dbo].[LimitAssuredSum] (
    [LimitAssuredSumId] INT IDENTITY (1, 1) NOT NULL,
    [BusinessUnitId]    INT NOT NULL,
    [ProductId]         INT NOT NULL,
    [IndividualStop]    INT NOT NULL,
    [AccumulatedStop]   INT NOT NULL,
    CONSTRAINT [PK_LimitAssuredSum] PRIMARY KEY CLUSTERED ([LimitAssuredSumId] ASC)
);


GO
PRINT N'Creating [dbo].[LimitRefund]...';


GO
CREATE TABLE [dbo].[LimitRefund] (
    [LimitRefundId]  INT        IDENTITY (1, 1) NOT NULL,
    [BusinessUnitId] INT        NOT NULL,
    [RiskType]       SMALLINT   NOT NULL,
    [Limit]          FLOAT (53) NULL,
    CONSTRAINT [PK_LimitRefund] PRIMARY KEY CLUSTERED ([LimitRefundId] ASC)
);


GO
PRINT N'Creating [dbo].[Location]...';


GO
CREATE TABLE [dbo].[Location] (
    [LocationId]  INT           IDENTITY (1, 1) NOT NULL,
    [Description] VARCHAR (200) NOT NULL,
    [StateId]     INT           NOT NULL,
    [ZipCode]     INT           NOT NULL,
    CONSTRAINT [PK_Location] PRIMARY KEY CLUSTERED ([LocationId] ASC)
);


GO
PRINT N'Creating [dbo].[LocationRisk]...';


GO
CREATE TABLE [dbo].[LocationRisk] (
    [LocationRiskId] INT IDENTITY (1, 1) NOT NULL,
    [BusinessUnitId] INT NOT NULL,
    [LocationId]     INT NOT NULL,
    [ZipCode]        INT NOT NULL,
    [RiskId]         INT NULL,
    CONSTRAINT [PK_LocationRisk] PRIMARY KEY CLUSTERED ([LocationRiskId] ASC)
);


GO
PRINT N'Creating [dbo].[MailType]...';


GO
CREATE TABLE [dbo].[MailType] (
    [MailTypeId]  INT           IDENTITY (1, 1) NOT NULL,
    [Description] VARCHAR (200) NOT NULL,
    [Subject]     VARCHAR (500) NOT NULL,
    [Message]     TEXT          NOT NULL,
    CONSTRAINT [PK_MailType] PRIMARY KEY CLUSTERED ([MailTypeId] ASC)
);


GO
PRINT N'Creating [dbo].[MessageType]...';


GO
CREATE TABLE [dbo].[MessageType] (
    [MessageTypeId] INT           IDENTITY (1, 1) NOT NULL,
    [Description]   VARCHAR (200) NOT NULL,
    CONSTRAINT [PK_MessageType] PRIMARY KEY CLUSTERED ([MessageTypeId] ASC)
);


GO
PRINT N'Creating [dbo].[News]...';


GO
CREATE TABLE [dbo].[News] (
    [NewsId]           INT           IDENTITY (1, 1) NOT NULL,
    [BusinessUnitId]   INT           NOT NULL,
    [CaseId]           INT           NOT NULL,
    [NewsTypeId]       INT           NOT NULL,
    [StatusId]         INT           NOT NULL,
    [CreateDate]       DATETIME2 (7) NOT NULL,
    [EndDate]          DATETIME2 (7) NULL,
    [ExpirationDate]   DATETIME2 (7) NULL,
    [Comments]         TEXT          NULL,
    [NewsReasonTypeId] INT           NULL,
    CONSTRAINT [PK_News] PRIMARY KEY CLUSTERED ([NewsId] ASC)
);


GO
PRINT N'Creating [dbo].[NewsDocument]...';


GO
CREATE TABLE [dbo].[NewsDocument] (
    [NewsDocumentId]       INT           IDENTITY (1, 1) NOT NULL,
    [NewsId]               INT           NOT NULL,
    [DocumentLetterTypeId] INT           NOT NULL,
    [ContactAddress]       VARCHAR (500) NOT NULL,
    [ContactZipCode]       INT           NOT NULL,
    [ContactLocationId]    INT           NOT NULL,
    [Processed]            BIT           NOT NULL,
    CONSTRAINT [PK_NewsDocument] PRIMARY KEY CLUSTERED ([NewsDocumentId] ASC)
);


GO
PRINT N'Creating [dbo].[NewsMail]...';


GO
CREATE TABLE [dbo].[NewsMail] (
    [NewsMailId]     INT           IDENTITY (1, 1) NOT NULL,
    [CaseId]         INT           NOT NULL,
    [NewsId]         INT           NOT NULL,
    [BusinessUnitId] INT           NOT NULL,
    [ContactMail]    VARCHAR (200) NOT NULL,
    [MailTypeId]     INT           NOT NULL,
    [Subject]        VARCHAR (500) NOT NULL,
    [Message]        TEXT          NOT NULL,
    CONSTRAINT [PK_NewsMail] PRIMARY KEY CLUSTERED ([NewsMailId] ASC)
);


GO
PRINT N'Creating [dbo].[NewsReason]...';


GO
CREATE TABLE [dbo].[NewsReason] (
    [NewsReasonId]     INT IDENTITY (1, 1) NOT NULL,
    [NewsTypeId]       INT NOT NULL,
    [NewsReasonTypeId] INT NOT NULL,
    CONSTRAINT [PK_NewsReason] PRIMARY KEY CLUSTERED ([NewsReasonId] ASC)
);


GO
PRINT N'Creating [dbo].[NewsReasonType]...';


GO
CREATE TABLE [dbo].[NewsReasonType] (
    [NewsReasonTypeId] INT           IDENTITY (1, 1) NOT NULL,
    [Description]      VARCHAR (200) NOT NULL,
    [Global]           BIT           NOT NULL,
    CONSTRAINT [PK_NewsReasonType] PRIMARY KEY CLUSTERED ([NewsReasonTypeId] ASC)
);


GO
PRINT N'Creating [dbo].[NewsRiskChange]...';


GO
CREATE TABLE [dbo].[NewsRiskChange] (
    [NewsRiskChangeId] INT      IDENTITY (1, 1) NOT NULL,
    [CaseId]           INT      NOT NULL,
    [NewsId]           INT      NOT NULL,
    [BusinessUnitId]   INT      NOT NULL,
    [NewRisk]          SMALLINT NOT NULL,
    CONSTRAINT [PK_NewsRiskChange] PRIMARY KEY CLUSTERED ([NewsRiskChangeId] ASC)
);


GO
PRINT N'Creating [dbo].[NewsType]...';


GO
CREATE TABLE [dbo].[NewsType] (
    [NewsTypeId]  INT           IDENTITY (1, 1) NOT NULL,
    [Description] VARCHAR (200) NOT NULL,
    CONSTRAINT [PK_NewsType] PRIMARY KEY CLUSTERED ([NewsTypeId] ASC)
);


GO
PRINT N'Creating [dbo].[Number]...';


GO
CREATE TABLE [dbo].[Number] (
    [NumberId]    INT           IDENTITY (1, 1) NOT NULL,
    [Description] VARCHAR (100) NULL,
    [Name]        VARCHAR (100) NULL,
    [Token]       VARCHAR (100) NULL,
    [LastNumber]  INT           NOT NULL,
    [Seed]        INT           NOT NULL,
    CONSTRAINT [PK_Number] PRIMARY KEY CLUSTERED ([NumberId] ASC)
);


GO
PRINT N'Creating [dbo].[OperatedVolume]...';


GO
CREATE TABLE [dbo].[OperatedVolume] (
    [OperatedVolumeId] INT        IDENTITY (1, 1) NOT NULL,
    [BusinessUnitId]   INT        NOT NULL,
    [FromDown]         FLOAT (53) NOT NULL,
    [FromMedium]       FLOAT (53) NOT NULL,
    CONSTRAINT [PK_OperatedVolume] PRIMARY KEY CLUSTERED ([OperatedVolumeId] ASC)
);


GO
PRINT N'Creating [dbo].[PaymentMode]...';


GO
CREATE TABLE [dbo].[PaymentMode] (
    [PaymentModeId] INT           IDENTITY (1, 1) NOT NULL,
    [Description]   VARCHAR (200) NOT NULL,
    CONSTRAINT [PK_PaymentMode] PRIMARY KEY CLUSTERED ([PaymentModeId] ASC)
);


GO
PRINT N'Creating [dbo].[PaymentModeRisk]...';


GO
CREATE TABLE [dbo].[PaymentModeRisk] (
    [PaymentModeRiskId] INT IDENTITY (1, 1) NOT NULL,
    [BusinessUnitId]    INT NOT NULL,
    [PaymentModeId]     INT NOT NULL,
    [RiskId]            INT NULL,
    CONSTRAINT [PK_PaymentModeRisk] PRIMARY KEY CLUSTERED ([PaymentModeRiskId] ASC)
);


GO
PRINT N'Creating [dbo].[Person]...';


GO
CREATE TABLE [dbo].[Person] (
    [PersonId]           INT           IDENTITY (1, 1) NOT NULL,
    [PersonKey]          VARCHAR (100) NOT NULL,
    [BusinessUnitId]     INT           NOT NULL,
    [Cuit]               VARCHAR (50)  NOT NULL,
    [LastName]           VARCHAR (200) NOT NULL,
    [FirstName]          VARCHAR (200) NOT NULL,
    [Active]             BIT           NOT NULL,
    [CreationDate]       DATETIME2 (2) NOT NULL,
    [UpdateDocumentDate] DATETIME2 (2) NULL,
    [Pep]                BIT           NULL,
    [PepSystem]          BIT           NULL,
    [RegisterUIF]        BIT           NULL,
    [Terrorist]          BIT           NULL,
    [CheckListDate]      DATETIME2 (2) NULL,
    [PersonType]         CHAR (1)      NULL,
    [Mail]               VARCHAR (200) NULL,
    [ActivityId]         INT           NULL,
    [LocationId]         INT           NULL,
    [Address]            VARCHAR (200) NULL,
    [OfficialTypeId]     VARCHAR (5)   NULL,
    [TaxId]              INT           NULL,
    [Nationality]        VARCHAR (100) NULL,
    [BirthDate]          DATETIME2 (2) NULL,
    [Maritalstatus]      VARCHAR (100) NULL,
    [PhoneNumber]        VARCHAR (200) NULL,
    [ThirdParty]         BIT           NOT NULL,
    [GroupCode]          INT           NULL,
    [Group]              BIT           NOT NULL,
    [ZipCode]            INT           NULL,
    [RegistrationDate]   DATETIME2 (2) NULL,
    [RegistrationNumber] VARCHAR (100) NULL,
    CONSTRAINT [FK_Person] PRIMARY KEY CLUSTERED ([PersonId] ASC)
);


GO
PRINT N'Creating [dbo].[PersonBusinessUnit]...';


GO
CREATE TABLE [dbo].[PersonBusinessUnit] (
    [PersonBusinessUnitId] INT IDENTITY (1, 1) NOT NULL,
    [PersonId]             INT NOT NULL,
    [BusinessUnitId]       INT NOT NULL,
    [FinancialProfile]     INT NULL,
    [CalcRisk]             INT NULL,
    [AssignedRisk]         INT NULL,
    [RiskId]               INT NULL,
    CONSTRAINT [PK_PersonBusinessUnit] PRIMARY KEY CLUSTERED ([PersonBusinessUnitId] ASC)
);


GO
PRINT N'Creating [dbo].[PersonWareHouse]...';


GO
CREATE TABLE [dbo].[PersonWareHouse] (
    [PersonWareHouseId]   INT           IDENTITY (1, 1) NOT NULL,
    [UniqueKey]           VARCHAR (50)  NULL,
    [PartnerNumber]       INT           NULL,
    [TaxId]               VARCHAR (50)  NULL,
    [LastNamePartner]     VARCHAR (300) NULL,
    [FirstNamePartner]    VARCHAR (300) NULL,
    [PersonType]          CHAR (1)      NOT NULL,
    [Email]               VARCHAR (100) NULL,
    [ActivityId]          INT           NULL,
    [ActivityDescription] VARCHAR (200) NULL,
    [UIFStatus]           VARCHAR (2)   NULL,
    [Nationality]         VARCHAR (100) NULL,
    [CountryOfResidence]  VARCHAR (100) NULL,
    [Address]             VARCHAR (300) NULL,
    [Location]            VARCHAR (200) NULL,
    [ZipCode]             INT           NULL,
    [State]               VARCHAR (150) NULL,
    [Country]             VARCHAR (150) NULL,
    [PolicyFirstDate]     DATE          NULL,
    CONSTRAINT [PK_PersonWareHouse] PRIMARY KEY CLUSTERED ([PersonWareHouseId] ASC)
);


GO
PRINT N'Creating [dbo].[PolicyType]...';


GO
CREATE TABLE [dbo].[PolicyType] (
    [PolicyTypeId] INT           IDENTITY (1, 1) NOT NULL,
    [Description]  VARCHAR (100) NOT NULL,
    [BranchId]     INT           NOT NULL,
    CONSTRAINT [PK_PolicyType] PRIMARY KEY CLUSTERED ([PolicyTypeId] ASC)
);


GO
PRINT N'Creating [dbo].[Processes]...';


GO
CREATE TABLE [dbo].[Processes] (
    [ProcessesId] INT           IDENTITY (1, 1) NOT NULL,
    [Description] VARCHAR (200) NOT NULL,
    CONSTRAINT [PK_Processes] PRIMARY KEY CLUSTERED ([ProcessesId] ASC)
);


GO
PRINT N'Creating [dbo].[ProcessesLog]...';


GO
CREATE TABLE [dbo].[ProcessesLog] (
    [ProcessesLogId] INT           IDENTITY (1, 1) NOT NULL,
    [ProcessesId]    INT           NOT NULL,
    [Message]        TEXT          NOT NULL,
    [MessageTypeId]  INT           NOT NULL,
    [Date]           DATETIME2 (7) NOT NULL,
    [BusinessUnitId] INT           NOT NULL,
    CONSTRAINT [PK_ProcessesLog] PRIMARY KEY CLUSTERED ([ProcessesLogId] ASC)
);


GO
PRINT N'Creating [dbo].[ProcessesRisk]...';


GO
CREATE TABLE [dbo].[ProcessesRisk] (
    [ProcessesRiskId] INT IDENTITY (1, 1) NOT NULL,
    [BusinessUnitId]  INT NOT NULL,
    [ProductId]       INT NOT NULL,
    [RiskId]          INT NULL,
    CONSTRAINT [PK_ProcessesRisk] PRIMARY KEY CLUSTERED ([ProcessesRiskId] ASC)
);


GO
PRINT N'Creating [dbo].[Producer]...';


GO
CREATE TABLE [dbo].[Producer] (
    [ProducerId]     INT           IDENTITY (1, 1) NOT NULL,
    [BusinessUnitId] INT           NOT NULL,
    [ProduceName]    VARCHAR (200) NOT NULL,
    [Mail]           VARCHAR (200) NULL,
    [OriginCode]     VARCHAR (50)  NULL,
    CONSTRAINT [PK_Producer] PRIMARY KEY CLUSTERED ([ProducerId] ASC)
);


GO
PRINT N'Creating [dbo].[Product]...';


GO
CREATE TABLE [dbo].[Product] (
    [ProductId]   INT           IDENTITY (1, 1) NOT NULL,
    [Description] VARCHAR (200) NOT NULL,
    CONSTRAINT [Key142] PRIMARY KEY CLUSTERED ([ProductId] ASC)
);


GO
PRINT N'Creating [dbo].[Risk]...';


GO
CREATE TABLE [dbo].[Risk] (
    [RiskId]      INT           IDENTITY (1, 1) NOT NULL,
    [Description] VARCHAR (300) NOT NULL,
    CONSTRAINT [PK_Risk] PRIMARY KEY CLUSTERED ([RiskId] ASC)
);


GO
PRINT N'Creating [dbo].[RiskAssignmentRanges]...';


GO
CREATE TABLE [dbo].[RiskAssignmentRanges] (
    [RiskAssignmentRangesId] INT        IDENTITY (1, 1) NOT NULL,
    [BusinessUnitId]         INT        NOT NULL,
    [Pep]                    BIT        NOT NULL,
    [LimitDown]              FLOAT (53) NOT NULL,
    [LimitMedium]            FLOAT (53) NOT NULL,
    CONSTRAINT [PK_RiskAssignmentRanges] PRIMARY KEY CLUSTERED ([RiskAssignmentRangesId] ASC)
);


GO
PRINT N'Creating [dbo].[RiskAssignmentRangesLog]...';


GO
CREATE TABLE [dbo].[RiskAssignmentRangesLog] (
    [RiskAssignmentRangesLogId] INT        IDENTITY (1, 1) NOT NULL,
    [BusinessUnitId]            INT        NOT NULL,
    [Pep]                       BIT        NOT NULL,
    [LimitDown]                 FLOAT (53) NOT NULL,
    [LimitHigh]                 FLOAT (53) NOT NULL,
    CONSTRAINT [PK_RiskAssignmentRangesLog] PRIMARY KEY CLUSTERED ([RiskAssignmentRangesLogId] ASC)
);


GO
PRINT N'Creating [dbo].[Setting]...';


GO
CREATE TABLE [dbo].[Setting] (
    [SettingId]     INT             IDENTITY (1, 1) NOT NULL,
    [SettingName]   VARCHAR (200)   NOT NULL,
    [StringValue]   VARCHAR (1000)  NULL,
    [IntValue]      INT             NULL,
    [DecimalValue]  DECIMAL (18, 2) NULL,
    [DateTimeValue] DATETIME2 (7)   NULL,
    [BooleanValue]  BIT             NULL,
    [Edit]          BIT             NOT NULL,
    [Description]   VARCHAR (1000)  NULL,
    CONSTRAINT [PK_Setting] PRIMARY KEY CLUSTERED ([SettingId] ASC)
);


GO
PRINT N'Creating [dbo].[SettingLog]...';


GO
CREATE TABLE [dbo].[SettingLog] (
    [SettingLogId] INT            IDENTITY (1, 1) NOT NULL,
    [SettingName]  VARCHAR (200)  NOT NULL,
    [OldValue]     VARCHAR (1000) NULL,
    [ActualValue]  VARCHAR (1000) NOT NULL,
    CONSTRAINT [PK_SettingLog] PRIMARY KEY CLUSTERED ([SettingLogId] ASC)
);


GO
PRINT N'Creating [dbo].[State]...';


GO
CREATE TABLE [dbo].[State] (
    [StateId]     INT           IDENTITY (1, 1) NOT NULL,
    [Description] VARCHAR (200) NOT NULL,
    [CountryId]   INT           NOT NULL,
    CONSTRAINT [PK_State] PRIMARY KEY CLUSTERED ([StateId] ASC)
);


GO
PRINT N'Creating [dbo].[Status]...';


GO
CREATE TABLE [dbo].[Status] (
    [StatusId]          INT           IDENTITY (1, 1) NOT NULL,
    [Description]       VARCHAR (300) NOT NULL,
    [Finisher]          BIT           NOT NULL,
    [DefaultExpiration] INT           NULL,
    [WarningDays]       INT           NULL,
    CONSTRAINT [PK_Status] PRIMARY KEY CLUSTERED ([StatusId] ASC)
);


GO
PRINT N'Creating [dbo].[UserProfile]...';


GO
CREATE TABLE [dbo].[UserProfile] (
    [UserProfileId] INT           IDENTITY (1, 1) NOT NULL,
    [Description]   VARCHAR (200) NOT NULL,
    CONSTRAINT [PK_UserProfile] PRIMARY KEY CLUSTERED ([UserProfileId] ASC)
);


GO
PRINT N'Creating [dbo].[UseType]...';


GO
CREATE TABLE [dbo].[UseType] (
    [UseTypeId]   INT           IDENTITY (1, 1) NOT NULL,
    [Description] VARCHAR (150) NOT NULL,
    CONSTRAINT [PK_UseType] PRIMARY KEY CLUSTERED ([UseTypeId] ASC)
);


GO
PRINT N'Creating [dbo].[Vehicle]...';


GO
CREATE TABLE [dbo].[Vehicle] (
    [VehicleId]    INT           IDENTITY (1, 1) NOT NULL,
    [LicensePlate] VARCHAR (50)  NOT NULL,
    [Make]         VARCHAR (200) NULL,
    [Model]        VARCHAR (300) NULL,
    [Version]      VARCHAR (300) NULL,
    [Year]         SMALLINT      NULL,
    CONSTRAINT [PK_Vehicle] PRIMARY KEY CLUSTERED ([VehicleId] ASC)
);


GO
PRINT N'Creating [fwk].[DF_fwk_Table_HasAudit]...';


GO
ALTER TABLE [fwk].[Table]
    ADD CONSTRAINT [DF_fwk_Table_HasAudit] DEFAULT ((0)) FOR [HasAudit];


GO
PRINT N'Creating [fwk].[DF_fwk_Table_IsSystemData]...';


GO
ALTER TABLE [fwk].[Table]
    ADD CONSTRAINT [DF_fwk_Table_IsSystemData] DEFAULT ((0)) FOR [IsSystemData];


GO
PRINT N'Creating [fwk].[DF_fwk_Table_IsAdministeringByUser]...';


GO
ALTER TABLE [fwk].[Table]
    ADD CONSTRAINT [DF_fwk_Table_IsAdministeringByUser] DEFAULT ((0)) FOR [IsAdministeringByUser];


GO
PRINT N'Creating [fwk].[DF_fwk_Table_HasSystemRecords]...';


GO
ALTER TABLE [fwk].[Table]
    ADD CONSTRAINT [DF_fwk_Table_HasSystemRecords] DEFAULT ((0)) FOR [HasSystemRecords];


GO
PRINT N'Creating [fwk].[DF_fwk_Table_IsParameterData]...';


GO
ALTER TABLE [fwk].[Table]
    ADD CONSTRAINT [DF_fwk_Table_IsParameterData] DEFAULT ((0)) FOR [IsParameterData];


GO
PRINT N'Creating [fwk].[DF_fwk_Table_IsTransactionData]...';


GO
ALTER TABLE [fwk].[Table]
    ADD CONSTRAINT [DF_fwk_Table_IsTransactionData] DEFAULT ((0)) FOR [IsTransactionData];


GO
PRINT N'Creating [fwk].[DF_fwk_Table_NotDeleteTrigger]...';


GO
ALTER TABLE [fwk].[Table]
    ADD CONSTRAINT [DF_fwk_Table_NotDeleteTrigger] DEFAULT ((0)) FOR [NotDeleteTrigger];


GO
PRINT N'Creating [fwk].[DF_fwk_Table_NotUpdateTrigger]...';


GO
ALTER TABLE [fwk].[Table]
    ADD CONSTRAINT [DF_fwk_Table_NotUpdateTrigger] DEFAULT ((0)) FOR [NotUpdateTrigger];


GO
PRINT N'Creating [fwk].[DF_fwk_Table_NotAuditField]...';


GO
ALTER TABLE [fwk].[Table]
    ADD CONSTRAINT [DF_fwk_Table_NotAuditField] DEFAULT ((0)) FOR [NotAuditField];


GO
PRINT N'Creating [fwk].[df_fwk_Table_HasInsertAudit]...';


GO
ALTER TABLE [fwk].[Table]
    ADD CONSTRAINT [df_fwk_Table_HasInsertAudit] DEFAULT ((0)) FOR [HasInsertAudit];


GO
PRINT N'Creating [fwk].[df_fwk_table_HasUpdateAudit]...';


GO
ALTER TABLE [fwk].[Table]
    ADD CONSTRAINT [df_fwk_table_HasUpdateAudit] DEFAULT ((0)) FOR [HasUpdateAudit];


GO
PRINT N'Creating [fwk].[df_fwk_table_HasDeleteAudit]...';


GO
ALTER TABLE [fwk].[Table]
    ADD CONSTRAINT [df_fwk_table_HasDeleteAudit] DEFAULT ((0)) FOR [HasDeleteAudit];


GO
PRINT N'Creating unnamed constraint on [dbo].[Number]...';


GO
ALTER TABLE [dbo].[Number]
    ADD DEFAULT (0) FOR [LastNumber];


GO
PRINT N'Creating unnamed constraint on [dbo].[Number]...';


GO
ALTER TABLE [dbo].[Number]
    ADD DEFAULT (1) FOR [Seed];


GO
PRINT N'Creating [dbo].[FK_ActivityRisk]...';


GO
ALTER TABLE [dbo].[ActivityRisk] WITH NOCHECK
    ADD CONSTRAINT [FK_ActivityRisk] FOREIGN KEY ([ActivityId]) REFERENCES [dbo].[Activity] ([ActivityId]);


GO
PRINT N'Creating [dbo].[FK_ActivityRisk_BusinessUnit]...';


GO
ALTER TABLE [dbo].[ActivityRisk] WITH NOCHECK
    ADD CONSTRAINT [FK_ActivityRisk_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_Antiquity_BusinessUnit]...';


GO
ALTER TABLE [dbo].[Antiquity] WITH NOCHECK
    ADD CONSTRAINT [FK_Antiquity_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_CaseDocument_Document]...';


GO
ALTER TABLE [dbo].[CaseDocument] WITH NOCHECK
    ADD CONSTRAINT [FK_CaseDocument_Document] FOREIGN KEY ([DocumentId]) REFERENCES [dbo].[Document] ([DocumentId]);


GO
PRINT N'Creating [dbo].[FK_CaseDocument_BusinessUnit]...';


GO
ALTER TABLE [dbo].[CaseDocument] WITH NOCHECK
    ADD CONSTRAINT [FK_CaseDocument_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_CaseType_CaseGroup]...';


GO
ALTER TABLE [dbo].[CaseType] WITH NOCHECK
    ADD CONSTRAINT [FK_CaseType_CaseGroup] FOREIGN KEY ([CaseGroupId]) REFERENCES [dbo].[CaseGroup] ([CaseGroupId]);


GO
PRINT N'Creating [dbo].[FK_CaseVehicle_BusinessUnit]...';


GO
ALTER TABLE [dbo].[CaseVehicle] WITH NOCHECK
    ADD CONSTRAINT [FK_CaseVehicle_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_ChannelRisk_BusinessUnit]...';


GO
ALTER TABLE [dbo].[ChannelRisk] WITH NOCHECK
    ADD CONSTRAINT [FK_ChannelRisk_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_ChannelRisk_Channel]...';


GO
ALTER TABLE [dbo].[ChannelRisk] WITH NOCHECK
    ADD CONSTRAINT [FK_ChannelRisk_Channel] FOREIGN KEY ([ChannelId]) REFERENCES [dbo].[Channel] ([ChannelId]);


GO
PRINT N'Creating [dbo].[FK_ChannelRisk_Risk]...';


GO
ALTER TABLE [dbo].[ChannelRisk] WITH NOCHECK
    ADD CONSTRAINT [FK_ChannelRisk_Risk] FOREIGN KEY ([RiskId]) REFERENCES [dbo].[Risk] ([RiskId]);


GO
PRINT N'Creating [dbo].[FK_Document_DocumentType]...';


GO
ALTER TABLE [dbo].[Document] WITH NOCHECK
    ADD CONSTRAINT [FK_Document_DocumentType] FOREIGN KEY ([DocumentTypeId]) REFERENCES [dbo].[DocumentType] ([DocumentTypeId]);


GO
PRINT N'Creating [dbo].[FK_Document_Person]...';


GO
ALTER TABLE [dbo].[Document] WITH NOCHECK
    ADD CONSTRAINT [FK_Document_Person] FOREIGN KEY ([PersonId]) REFERENCES [dbo].[Person] ([PersonId]);


GO
PRINT N'Creating [dbo].[FK_Document_PersonOriginal]...';


GO
ALTER TABLE [dbo].[Document] WITH NOCHECK
    ADD CONSTRAINT [FK_Document_PersonOriginal] FOREIGN KEY ([PersonId]) REFERENCES [dbo].[Person] ([PersonId]);


GO
PRINT N'Creating [dbo].[FK_DocumentVersion_Document]...';


GO
ALTER TABLE [dbo].[DocumentVersion] WITH NOCHECK
    ADD CONSTRAINT [FK_DocumentVersion_Document] FOREIGN KEY ([DocumentId]) REFERENCES [dbo].[Document] ([DocumentId]) ON DELETE CASCADE;


GO
PRINT N'Creating [dbo].[FK_FinancialProfilesDefault_BusinessUnit]...';


GO
ALTER TABLE [dbo].[FinancialProfilesDefault] WITH NOCHECK
    ADD CONSTRAINT [FK_FinancialProfilesDefault_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_FinancialProfilesDefaultLog_BusinessUnit]...';


GO
ALTER TABLE [dbo].[FinancialProfilesDefaultLog] WITH NOCHECK
    ADD CONSTRAINT [FK_FinancialProfilesDefaultLog_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_GrayList_PersonOriginal]...';


GO
ALTER TABLE [dbo].[GrayList] WITH NOCHECK
    ADD CONSTRAINT [FK_GrayList_PersonOriginal] FOREIGN KEY ([PersonOriginalId]) REFERENCES [dbo].[Person] ([PersonId]);


GO
PRINT N'Creating [dbo].[FK_GrayList_Person]...';


GO
ALTER TABLE [dbo].[GrayList] WITH NOCHECK
    ADD CONSTRAINT [FK_GrayList_Person] FOREIGN KEY ([PersonId]) REFERENCES [dbo].[Person] ([PersonId]);


GO
PRINT N'Creating [dbo].[FK_GrayListDocument_GrayList]...';


GO
ALTER TABLE [dbo].[GrayListDocument] WITH NOCHECK
    ADD CONSTRAINT [FK_GrayListDocument_GrayList] FOREIGN KEY ([GrayListId]) REFERENCES [dbo].[GrayList] ([GrayListId]);


GO
PRINT N'Creating [dbo].[FK_GrayListDocument_Document]...';


GO
ALTER TABLE [dbo].[GrayListDocument] WITH NOCHECK
    ADD CONSTRAINT [FK_GrayListDocument_Document] FOREIGN KEY ([DocumentId]) REFERENCES [dbo].[Document] ([DocumentId]);


GO
PRINT N'Creating [dbo].[FK_LimitAccumulatedClaimsCharged_BusinessUnit]...';


GO
ALTER TABLE [dbo].[LimitAccumulatedClaimsCharged] WITH NOCHECK
    ADD CONSTRAINT [FK_LimitAccumulatedClaimsCharged_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_LimitAccumulatedPremium_BusinessUnit]...';


GO
ALTER TABLE [dbo].[LimitAccumulatedPremium] WITH NOCHECK
    ADD CONSTRAINT [FK_LimitAccumulatedPremium_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_LimitAssuredSum_Product]...';


GO
ALTER TABLE [dbo].[LimitAssuredSum] WITH NOCHECK
    ADD CONSTRAINT [FK_LimitAssuredSum_Product] FOREIGN KEY ([ProductId]) REFERENCES [dbo].[Product] ([ProductId]);


GO
PRINT N'Creating [dbo].[FK_LimitAssuredSum_BusinessUnit]...';


GO
ALTER TABLE [dbo].[LimitAssuredSum] WITH NOCHECK
    ADD CONSTRAINT [FK_LimitAssuredSum_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_LimitRefund_BusinessUnit]...';


GO
ALTER TABLE [dbo].[LimitRefund] WITH NOCHECK
    ADD CONSTRAINT [FK_LimitRefund_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_Location_State]...';


GO
ALTER TABLE [dbo].[Location] WITH NOCHECK
    ADD CONSTRAINT [FK_Location_State] FOREIGN KEY ([StateId]) REFERENCES [dbo].[State] ([StateId]);


GO
PRINT N'Creating [dbo].[FK_LocationRisk_Location]...';


GO
ALTER TABLE [dbo].[LocationRisk] WITH NOCHECK
    ADD CONSTRAINT [FK_LocationRisk_Location] FOREIGN KEY ([LocationId]) REFERENCES [dbo].[Location] ([LocationId]);


GO
PRINT N'Creating [dbo].[FK_LocationRisk_BusinessUnit]...';


GO
ALTER TABLE [dbo].[LocationRisk] WITH NOCHECK
    ADD CONSTRAINT [FK_LocationRisk_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_LocationRisk_Risk]...';


GO
ALTER TABLE [dbo].[LocationRisk] WITH NOCHECK
    ADD CONSTRAINT [FK_LocationRisk_Risk] FOREIGN KEY ([RiskId]) REFERENCES [dbo].[Risk] ([RiskId]);


GO
PRINT N'Creating [dbo].[FK_News_Status]...';


GO
ALTER TABLE [dbo].[News] WITH NOCHECK
    ADD CONSTRAINT [FK_News_Status] FOREIGN KEY ([StatusId]) REFERENCES [dbo].[Status] ([StatusId]);


GO
PRINT N'Creating [dbo].[FK_News_NewsType]...';


GO
ALTER TABLE [dbo].[News] WITH NOCHECK
    ADD CONSTRAINT [FK_News_NewsType] FOREIGN KEY ([NewsTypeId]) REFERENCES [dbo].[NewsType] ([NewsTypeId]);


GO
PRINT N'Creating [dbo].[FK_News_NewsReasonType]...';


GO
ALTER TABLE [dbo].[News] WITH NOCHECK
    ADD CONSTRAINT [FK_News_NewsReasonType] FOREIGN KEY ([NewsReasonTypeId]) REFERENCES [dbo].[NewsReasonType] ([NewsReasonTypeId]);


GO
PRINT N'Creating [dbo].[FK_News_BusinessUnit]...';


GO
ALTER TABLE [dbo].[News] WITH NOCHECK
    ADD CONSTRAINT [FK_News_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_NewsDocument_News]...';


GO
ALTER TABLE [dbo].[NewsDocument] WITH NOCHECK
    ADD CONSTRAINT [FK_NewsDocument_News] FOREIGN KEY ([NewsId]) REFERENCES [dbo].[News] ([NewsId]);


GO
PRINT N'Creating [dbo].[FK_NewsDocument_DocumentLetterType]...';


GO
ALTER TABLE [dbo].[NewsDocument] WITH NOCHECK
    ADD CONSTRAINT [FK_NewsDocument_DocumentLetterType] FOREIGN KEY ([DocumentLetterTypeId]) REFERENCES [dbo].[DocumentLetterType] ([DocumentLetterTypeId]);


GO
PRINT N'Creating [dbo].[FK_NewsDocument_Location]...';


GO
ALTER TABLE [dbo].[NewsDocument] WITH NOCHECK
    ADD CONSTRAINT [FK_NewsDocument_Location] FOREIGN KEY ([ContactLocationId]) REFERENCES [dbo].[Location] ([LocationId]);


GO
PRINT N'Creating [dbo].[FK_NewsMail_News]...';


GO
ALTER TABLE [dbo].[NewsMail] WITH NOCHECK
    ADD CONSTRAINT [FK_NewsMail_News] FOREIGN KEY ([NewsId]) REFERENCES [dbo].[News] ([NewsId]);


GO
PRINT N'Creating [dbo].[FK_NewsMail_MailType]...';


GO
ALTER TABLE [dbo].[NewsMail] WITH NOCHECK
    ADD CONSTRAINT [FK_NewsMail_MailType] FOREIGN KEY ([MailTypeId]) REFERENCES [dbo].[MailType] ([MailTypeId]);


GO
PRINT N'Creating [dbo].[FK_NewsMail_BusinessUnit]...';


GO
ALTER TABLE [dbo].[NewsMail] WITH NOCHECK
    ADD CONSTRAINT [FK_NewsMail_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_NewsReason]...';


GO
ALTER TABLE [dbo].[NewsReason] WITH NOCHECK
    ADD CONSTRAINT [FK_NewsReason] FOREIGN KEY ([NewsTypeId]) REFERENCES [dbo].[NewsType] ([NewsTypeId]);


GO
PRINT N'Creating [dbo].[FK_NewsReason_NewsReasonType]...';


GO
ALTER TABLE [dbo].[NewsReason] WITH NOCHECK
    ADD CONSTRAINT [FK_NewsReason_NewsReasonType] FOREIGN KEY ([NewsReasonTypeId]) REFERENCES [dbo].[NewsReasonType] ([NewsReasonTypeId]);


GO
PRINT N'Creating [dbo].[FK_NewsRiskChange_News]...';


GO
ALTER TABLE [dbo].[NewsRiskChange] WITH NOCHECK
    ADD CONSTRAINT [FK_NewsRiskChange_News] FOREIGN KEY ([NewsId]) REFERENCES [dbo].[News] ([NewsId]);


GO
PRINT N'Creating [dbo].[FK_NewsRiskChange_BusinessUnit]...';


GO
ALTER TABLE [dbo].[NewsRiskChange] WITH NOCHECK
    ADD CONSTRAINT [FK_NewsRiskChange_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_OperatedVolume_BusinessUnit]...';


GO
ALTER TABLE [dbo].[OperatedVolume] WITH NOCHECK
    ADD CONSTRAINT [FK_OperatedVolume_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_PaymentModeRisk_PaymentMode]...';


GO
ALTER TABLE [dbo].[PaymentModeRisk] WITH NOCHECK
    ADD CONSTRAINT [FK_PaymentModeRisk_PaymentMode] FOREIGN KEY ([PaymentModeId]) REFERENCES [dbo].[PaymentMode] ([PaymentModeId]);


GO
PRINT N'Creating [dbo].[FK_PaymentModeRisk_BusinessUnit]...';


GO
ALTER TABLE [dbo].[PaymentModeRisk] WITH NOCHECK
    ADD CONSTRAINT [FK_PaymentModeRisk_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_PaymentModeRisk_Risk]...';


GO
ALTER TABLE [dbo].[PaymentModeRisk] WITH NOCHECK
    ADD CONSTRAINT [FK_PaymentModeRisk_Risk] FOREIGN KEY ([RiskId]) REFERENCES [dbo].[Risk] ([RiskId]);


GO
PRINT N'Creating [dbo].[FK_Person_Activity]...';


GO
ALTER TABLE [dbo].[Person] WITH NOCHECK
    ADD CONSTRAINT [FK_Person_Activity] FOREIGN KEY ([ActivityId]) REFERENCES [dbo].[Activity] ([ActivityId]);


GO
PRINT N'Creating [dbo].[FK_Person_Location]...';


GO
ALTER TABLE [dbo].[Person] WITH NOCHECK
    ADD CONSTRAINT [FK_Person_Location] FOREIGN KEY ([LocationId]) REFERENCES [dbo].[Location] ([LocationId]);


GO
PRINT N'Creating [dbo].[FK_Person_BusinessUnit]...';


GO
ALTER TABLE [dbo].[Person] WITH NOCHECK
    ADD CONSTRAINT [FK_Person_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_PersonBusinessUnit_Person]...';


GO
ALTER TABLE [dbo].[PersonBusinessUnit] WITH NOCHECK
    ADD CONSTRAINT [FK_PersonBusinessUnit_Person] FOREIGN KEY ([PersonId]) REFERENCES [dbo].[Person] ([PersonId]);


GO
PRINT N'Creating [dbo].[FK_PersonBusinessUnit_BusinessUnit]...';


GO
ALTER TABLE [dbo].[PersonBusinessUnit] WITH NOCHECK
    ADD CONSTRAINT [FK_PersonBusinessUnit_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_PersonBusinessUnit_Risk]...';


GO
ALTER TABLE [dbo].[PersonBusinessUnit] WITH NOCHECK
    ADD CONSTRAINT [FK_PersonBusinessUnit_Risk] FOREIGN KEY ([RiskId]) REFERENCES [dbo].[Risk] ([RiskId]);


GO
PRINT N'Creating [dbo].[FK_PersonWareHouse_Activity]...';


GO
ALTER TABLE [dbo].[PersonWareHouse] WITH NOCHECK
    ADD CONSTRAINT [FK_PersonWareHouse_Activity] FOREIGN KEY ([PersonWareHouseId]) REFERENCES [dbo].[Activity] ([ActivityId]);


GO
PRINT N'Creating [dbo].[FK_PolicyType_Branch]...';


GO
ALTER TABLE [dbo].[PolicyType] WITH NOCHECK
    ADD CONSTRAINT [FK_PolicyType_Branch] FOREIGN KEY ([BranchId]) REFERENCES [dbo].[Branch] ([BranchId]);


GO
PRINT N'Creating [dbo].[FK_ProcessesLog_Processes]...';


GO
ALTER TABLE [dbo].[ProcessesLog] WITH NOCHECK
    ADD CONSTRAINT [FK_ProcessesLog_Processes] FOREIGN KEY ([ProcessesId]) REFERENCES [dbo].[Processes] ([ProcessesId]);


GO
PRINT N'Creating [dbo].[FK_ProcessesLog_MessageType]...';


GO
ALTER TABLE [dbo].[ProcessesLog] WITH NOCHECK
    ADD CONSTRAINT [FK_ProcessesLog_MessageType] FOREIGN KEY ([MessageTypeId]) REFERENCES [dbo].[MessageType] ([MessageTypeId]);


GO
PRINT N'Creating [dbo].[FK_ProcessesLog_BusinessUnit]...';


GO
ALTER TABLE [dbo].[ProcessesLog] WITH NOCHECK
    ADD CONSTRAINT [FK_ProcessesLog_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_ProcessesRisk_Product]...';


GO
ALTER TABLE [dbo].[ProcessesRisk] WITH NOCHECK
    ADD CONSTRAINT [FK_ProcessesRisk_Product] FOREIGN KEY ([ProductId]) REFERENCES [dbo].[Product] ([ProductId]);


GO
PRINT N'Creating [dbo].[FK_ProcessesRisk_BusinessUnit]...';


GO
ALTER TABLE [dbo].[ProcessesRisk] WITH NOCHECK
    ADD CONSTRAINT [FK_ProcessesRisk_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_ProcessesRisk_Risk]...';


GO
ALTER TABLE [dbo].[ProcessesRisk] WITH NOCHECK
    ADD CONSTRAINT [FK_ProcessesRisk_Risk] FOREIGN KEY ([RiskId]) REFERENCES [dbo].[Risk] ([RiskId]);


GO
PRINT N'Creating [dbo].[FK_Producer_BusinessUnit]...';


GO
ALTER TABLE [dbo].[Producer] WITH NOCHECK
    ADD CONSTRAINT [FK_Producer_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_RiskAssignmentRanges_BusinessUnit]...';


GO
ALTER TABLE [dbo].[RiskAssignmentRanges] WITH NOCHECK
    ADD CONSTRAINT [FK_RiskAssignmentRanges_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_RiskAssignmentRangesLog_BusinessUnit]...';


GO
ALTER TABLE [dbo].[RiskAssignmentRangesLog] WITH NOCHECK
    ADD CONSTRAINT [FK_RiskAssignmentRangesLog_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_State_Country]...';


GO
ALTER TABLE [dbo].[State] WITH NOCHECK
    ADD CONSTRAINT [FK_State_Country] FOREIGN KEY ([CountryId]) REFERENCES [dbo].[Country] ([CountryId]);


GO
PRINT N'Creating [fwk].[CK01_fwk_Table]...';


GO
ALTER TABLE [fwk].[Table] WITH NOCHECK
    ADD CONSTRAINT [CK01_fwk_Table] CHECK (([IsSystemData]=(1) AND [HasSystemRecords]=(0) OR [IsSystemData]=(0)) AND ([IsSystemData]=(0) AND [IsAdministeringByUser]=(0) OR [IsSystemData]=(1)));


GO
PRINT N'Creating [dbo].[GetLastNewsByCaseID]...';


GO
CREATE FUNCTION [dbo].[GetLastNewsByCaseID]
(
	@caseID int
)
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
	Declare @newsID int;
	select @newsID = newsid from dbo.News where createdate = (select max(news.createdate) from dbo.News where news.caseid = @caseID) and caseid = @caseID;
	RETURN @newsID;
END
GO
PRINT N'Creating [dbo].[Case]...';


GO
CREATE TABLE [dbo].[Case] (
    [CaseId]           INT            IDENTITY (1, 1) NOT NULL,
    [BusinessUnitId]   INT            NOT NULL,
    [BranchOfficeId]   INT            NOT NULL,
    [CaseTypeId]       INT            NULL,
    [CaseNumber]       INT            NULL,
    [ActualStageId]    AS             dbo.GetLastNewsByCaseID(CaseId),
    [StatusId]         INT            NOT NULL,
    [RiskId]           INT            NOT NULL,
    [AnalystId]        INT            NOT NULL,
    [CreateDate]       DATETIME2 (7)  NOT NULL,
    [UpdateFile]       BIT            NULL,
    [ContactMail]      VARCHAR (100)  NULL,
    [ContactAddress]   VARCHAR (500)  NULL,
    [ContactZipCode]   INT            NULL,
    [ContactProvince]  VARCHAR (500)  NULL,
    [ContactCity]      VARCHAR (500)  NULL,
    [ContactStateId]   INT            NULL,
    [ProducerId]       INT            NULL,
    [PersonId]         INT            NULL,
    [OriginalPersonId] INT            NULL,
    [Comment]          VARCHAR (8000) NULL,
    [Value]            INT            NULL,
    CONSTRAINT [PK_Case] PRIMARY KEY CLUSTERED ([CaseId] ASC)
);


GO
PRINT N'Creating [dbo].[Case].[UK_Case_CaseNumberBusinessUnit]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UK_Case_CaseNumberBusinessUnit]
    ON [dbo].[Case]([BusinessUnitId] ASC, [CaseNumber] ASC) WHERE ([CaseNumber] IS NOT NULL)
    ON [PRIMARY];


GO
PRINT N'Creating [dbo].[FK_Case_CaseType]...';


GO
ALTER TABLE [dbo].[Case] WITH NOCHECK
    ADD CONSTRAINT [FK_Case_CaseType] FOREIGN KEY ([CaseTypeId]) REFERENCES [dbo].[CaseType] ([CaseTypeId]);


GO
PRINT N'Creating [dbo].[FK_Case_BranchOffice]...';


GO
ALTER TABLE [dbo].[Case] WITH NOCHECK
    ADD CONSTRAINT [FK_Case_BranchOffice] FOREIGN KEY ([BranchOfficeId]) REFERENCES [dbo].[BranchOffice] ([BranchOfficeId]);


GO
PRINT N'Creating [dbo].[FK_Case_Person]...';


GO
ALTER TABLE [dbo].[Case] WITH NOCHECK
    ADD CONSTRAINT [FK_Case_Person] FOREIGN KEY ([PersonId]) REFERENCES [dbo].[Person] ([PersonId]);


GO
PRINT N'Creating [dbo].[FK_Case_Producer]...';


GO
ALTER TABLE [dbo].[Case] WITH NOCHECK
    ADD CONSTRAINT [FK_Case_Producer] FOREIGN KEY ([ProducerId]) REFERENCES [dbo].[Producer] ([ProducerId]);


GO
PRINT N'Creating [dbo].[FK_Case_Status]...';


GO
ALTER TABLE [dbo].[Case] WITH NOCHECK
    ADD CONSTRAINT [FK_Case_Status] FOREIGN KEY ([StatusId]) REFERENCES [dbo].[Status] ([StatusId]);


GO
PRINT N'Creating [dbo].[FK_Case_OriginalPerson]...';


GO
ALTER TABLE [dbo].[Case] WITH NOCHECK
    ADD CONSTRAINT [FK_Case_OriginalPerson] FOREIGN KEY ([OriginalPersonId]) REFERENCES [dbo].[Person] ([PersonId]);


GO
PRINT N'Creating [dbo].[FK_Case_BusinessUnit]...';


GO
ALTER TABLE [dbo].[Case] WITH NOCHECK
    ADD CONSTRAINT [FK_Case_BusinessUnit] FOREIGN KEY ([BusinessUnitId]) REFERENCES [dbo].[BusinessUnit] ([BusinessUnitId]);


GO
PRINT N'Creating [dbo].[FK_Case_Risk]...';


GO
ALTER TABLE [dbo].[Case] WITH NOCHECK
    ADD CONSTRAINT [FK_Case_Risk] FOREIGN KEY ([RiskId]) REFERENCES [dbo].[Risk] ([RiskId]);


GO
PRINT N'Creating [dbo].[FK_CaseDocument_Case]...';


GO
ALTER TABLE [dbo].[CaseDocument] WITH NOCHECK
    ADD CONSTRAINT [FK_CaseDocument_Case] FOREIGN KEY ([CaseId]) REFERENCES [dbo].[Case] ([CaseId]);


GO
PRINT N'Creating [dbo].[FK_CaseVehicle_Case]...';


GO
ALTER TABLE [dbo].[CaseVehicle] WITH NOCHECK
    ADD CONSTRAINT [FK_CaseVehicle_Case] FOREIGN KEY ([CaseId]) REFERENCES [dbo].[Case] ([CaseId]);


GO
PRINT N'Creating [dbo].[FK_News_Cases]...';


GO
ALTER TABLE [dbo].[News] WITH NOCHECK
    ADD CONSTRAINT [FK_News_Cases] FOREIGN KEY ([CaseId]) REFERENCES [dbo].[Case] ([CaseId]) ON DELETE CASCADE;


GO
PRINT N'Creating [dbo].[GetNumber]...';


GO
CREATE PROCEDURE [dbo].[GetNumber]
(
	@Name varchar(100),
	@Token varchar(100),
	@Number INT OUTPUT
)
AS
BEGIN
	DECLARE @Seed INT;

	SET @Seed = (SELECT TOP 1 n.Seed  FROM Number n WHERE n.Name = @Name AND n.Token = @Token); 	
	SET @Number = (SELECT TOP 1 n.LastNumber  FROM Number n WHERE n.Name = @Name AND n.Token = @Token) + @Seed; 
	
	UPDATE Number
	SET LastNumber = @Number
	WHERE [Name] = @Name AND Token = @Token


END
GO
PRINT N'Creating [dbo].[sp_generate_merge]...';


GO
--Turn system object marking on

CREATE PROC [dbo].[sp_generate_merge]
(
 @table_name varchar(776), -- The table/view for which the MERGE statement will be generated using the existing data. This parameter accepts unquoted single-part identifiers only (e.g. MyTable)
 @target_table varchar(776) = NULL, -- Use this parameter to specify a different table name into which the data will be inserted/updated/deleted. This parameter accepts unquoted single-part identifiers (e.g. MyTable) or quoted multi-part identifiers (e.g. [OtherDb].[dbo].[MyTable])
 @from nvarchar(max) = NULL, -- Use this parameter to filter the rows based on a filter condition (using WHERE). Note: To avoid inconsistent ordering of results, including an ORDER BY clause is highly recommended
 @include_values bit = 1, -- When 1, a VALUES clause containing data from @table_name is generated. When 0, data will be sourced directly from @table_name when the MERGE is executed (see example 15 for use case)
 @include_timestamp bit = 0, -- [DEPRECATED] Sql Server does not allow modification of TIMESTAMP datatype
 @debug_mode bit = 0, -- If @debug_mode is set to 1, the SQL statements constructed by this procedure will be printed for later examination
 @schema varchar(64) = NULL, -- Use this parameter if you are not the owner of the table
 @ommit_images bit = 0, -- Use this parameter to generate MERGE statement by omitting the 'image' columns
 @ommit_identity bit = 0, -- Use this parameter to omit the identity columns
 @top int = NULL, -- Use this parameter to generate a MERGE statement only for the TOP n rows
 @cols_to_include varchar(max) = NULL, -- List of columns to be included in the MERGE statement
 @cols_to_exclude varchar(max) = NULL, -- List of columns to be excluded from the MERGE statement
 @cols_to_join_on varchar(max) = NULL, -- List of columns needed to JOIN the source table to the target table (useful when @table_name is missing a primary key) 
 @update_only_if_changed bit = 1, -- When 1, only performs an UPDATE operation if an included column in a matched row has changed.
 @delete_if_not_matched bit = 1, -- When 1, deletes unmatched source rows from target, when 0 source rows will only be used to update existing rows or insert new.
 @disable_constraints bit = 0, -- When 1, disables foreign key constraints and enables them after the MERGE statement
 @ommit_computed_cols bit = 1, -- When 1, computed columns will not be included in the MERGE statement
 @include_use_db bit = 1, -- When 1, includes a USE [DatabaseName] statement at the beginning of the generated batch
 @results_to_text bit = 0, -- When 1, outputs results to grid/messages window. When 0, outputs MERGE statement in an XML fragment.
 @include_rowsaffected bit = 1, -- When 1, a section is added to the end of the batch which outputs rows affected by the MERGE
 @nologo bit = 0, -- When 1, the "About" comment is suppressed from output
 @batch_separator varchar(50) = 'GO' -- Batch separator to use
)
AS
BEGIN

/***********************************************************************************************************
Procedure: sp_generate_merge
 (Adapted by Daniel Nolan for SQL Server 2008+)

Adapted from: sp_generate_inserts (Build 22) 
 (Copyright © 2002 Narayana Vyas Kondreddi. All rights reserved.)

Purpose: To generate a MERGE statement from existing data, which will INSERT/UPDATE/DELETE data based
 on matching primary key values in the source/target table.
 
 The generated statements can be executed to replicate the data in some other location.
 
 Typical use cases:
 * Generate statements for static data tables, store the .SQL file in source control and use 
 it as part of your Dev/Test/Prod deployment. The generated statements are re-runnable, so 
 you can make changes to the file and migrate those changes between environments.
 
 * Generate statements from your Production tables and then run those statements in your 
 Dev/Test environments. Schedule this as part of a SQL Job to keep all of your environments 
 in-sync.
 
 * Enter test data into your Dev environment, and then generate statements from the Dev
 tables so that you can always reproduce your test database with valid sample data.
 

Written by: Narayana Vyas Kondreddi
 http://vyaskn.tripod.com/code
 vyaskn@hotmail.com

 Daniel Nolan
 https://twitter.com/dnlnln
 dan@danere.com


Acknowledgements (sp_generate_merge):
 Nathan Skerl -- StackOverflow answer that provided a workaround for the output truncation problem
 http://stackoverflow.com/a/10489767/266882

 Bill Gibson -- Blog that detailed the static data table use case; the inspiration for this proc
 http://blogs.msdn.com/b/ssdt/archive/2012/02/02/including-data-in-an-sql-server-database-project.aspx
 
 Bill Graziano -- Blog that provided the groundwork for MERGE statement generation
 http://weblogs.sqlteam.com/billg/archive/2011/02/15/generate-merge-statements-from-a-table.aspx 

Acknowledgements (sp_generate_inserts):
 Divya Kalra -- For beta testing
 Mark Charsley -- For reporting a problem with scripting uniqueidentifier columns with NULL values
 Artur Zeygman -- For helping me simplify a bit of code for handling non-dbo owned tables
 Joris Laperre -- For reporting a regression bug in handling text/ntext columns

NOTE: This procedure may not work with tables with a large number of columns (> 500).
 Results can be unpredictable with huge text columns or SQL Server 2000's sql_variant data types
 IMPORTANT: This procedure has not been extensively tested with international data (Extended characters or Unicode). If needed
 you might want to convert the datatypes of character variables in this procedure to their respective unicode counterparts
 like nchar and nvarchar

Get Started: Ensure that your SQL client is configured to send results to grid (default SSMS behaviour).
This ensures that the generated MERGE statement can be output in full, getting around SSMS's 4000 nchar limit.
After running this proc, click the hyperlink within the single row returned to copy the generated MERGE statement.

Example 1: To generate a MERGE statement for table 'titles':
 
 EXEC sp_generate_merge 'titles'

Example 2: To generate a MERGE statement for 'titlesCopy' table from 'titles' table:

 EXEC sp_generate_merge 'titles', 'titlesCopy'

Example 3: To generate a MERGE statement for table 'titles' that will unconditionally UPDATE matching rows 
 (ie. not perform a "has data changed?" check prior to going ahead with an UPDATE):
 
 EXEC sp_generate_merge 'titles', @update_only_if_changed = 0

Example 4: To generate a MERGE statement for 'titles' table for only those titles 
 which contain the word 'Computer' in them:
 NOTE: Do not complicate the FROM or WHERE clause here. It's assumed that you are good with T-SQL if you are using this parameter

 EXEC sp_generate_merge 'titles', @from = "from titles where title like '%Computer%' order by title_id"

Example 5: To print the debug information:

 EXEC sp_generate_merge 'titles', @debug_mode = 1

Example 6: If the table is in a different schema to the default, use @schema parameter to specify the schema name
 To use this option, you must have SELECT permissions on that table

 EXEC sp_generate_merge 'Nickstable', @schema = 'Nick'

Example 7: To generate a MERGE statement for the rest of the columns excluding images

 EXEC sp_generate_merge 'imgtable', @ommit_images = 1

Example 8: To generate a MERGE statement excluding (omitting) IDENTITY columns:
 (By default IDENTITY columns are included in the MERGE statement)

 EXEC sp_generate_merge 'mytable', @ommit_identity = 1

Example 9: To generate a MERGE statement for the TOP 10 rows in the table:
 
 EXEC sp_generate_merge 'mytable', @top = 10

Example 10: To generate a MERGE statement with only those columns you want:
 
 EXEC sp_generate_merge 'titles', @cols_to_include = "'title','title_id','au_id'"

Example 11: To generate a MERGE statement by omitting certain columns:
 
 EXEC sp_generate_merge 'titles', @cols_to_exclude = "'title','title_id','au_id'"

Example 12: To avoid checking the foreign key constraints while loading data with a MERGE statement:
 
 EXEC sp_generate_merge 'titles', @disable_constraints = 1

Example 13: To exclude computed columns from the MERGE statement:

 EXEC sp_generate_merge 'MyTable', @ommit_computed_cols = 1

Example 14: To generate a MERGE statement for a table that lacks a primary key:
 
 EXEC sp_generate_merge 'StateProvince', @schema = 'Person', @cols_to_join_on = "'StateProvinceCode'"

Example 15: To generate a statement that MERGEs data directly from the source table to a table in another database:

EXEC sp_generate_merge 'StateProvince', @schema = 'Person', @include_values = 0, @target_table = '[OtherDb].[Person].[StateProvince]'

 
***********************************************************************************************************/

SET NOCOUNT ON


--Making sure user only uses either @cols_to_include or @cols_to_exclude
IF ((@cols_to_include IS NOT NULL) AND (@cols_to_exclude IS NOT NULL))
 BEGIN
 RAISERROR('Use either @cols_to_include or @cols_to_exclude. Do not use both the parameters at once',16,1)
 RETURN -1 --Failure. Reason: Both @cols_to_include and @cols_to_exclude parameters are specified
 END


--Making sure the @cols_to_include, @cols_to_exclude and @cols_to_join_on parameters are receiving values in proper format
IF ((@cols_to_include IS NOT NULL) AND (PATINDEX('''%''',@cols_to_include) = 0))
 BEGIN
 RAISERROR('Invalid use of @cols_to_include property',16,1)
 PRINT 'Specify column names surrounded by single quotes and separated by commas'
 PRINT 'Eg: EXEC sp_generate_merge "titles", @cols_to_include = "''title_id'',''title''"'
 RETURN -1 --Failure. Reason: Invalid use of @cols_to_include property
 END

IF ((@cols_to_exclude IS NOT NULL) AND (PATINDEX('''%''',@cols_to_exclude) = 0))
 BEGIN
 RAISERROR('Invalid use of @cols_to_exclude property',16,1)
 PRINT 'Specify column names surrounded by single quotes and separated by commas'
 PRINT 'Eg: EXEC sp_generate_merge "titles", @cols_to_exclude = "''title_id'',''title''"'
 RETURN -1 --Failure. Reason: Invalid use of @cols_to_exclude property
 END

IF ((@cols_to_join_on IS NOT NULL) AND (PATINDEX('''%''',@cols_to_join_on) = 0))
 BEGIN
 RAISERROR('Invalid use of @cols_to_join_on property',16,1)
 PRINT 'Specify column names surrounded by single quotes and separated by commas'
 PRINT 'Eg: EXEC sp_generate_merge "StateProvince", @schema = "Person", @cols_to_join_on = "''StateProvinceCode''"'
 RETURN -1 --Failure. Reason: Invalid use of @cols_to_join_on property
 END


--Checking to see if the database name is specified along wih the table name
--Your database context should be local to the table for which you want to generate a MERGE statement
--specifying the database name is not allowed
IF (PARSENAME(@table_name,3)) IS NOT NULL
 BEGIN
 RAISERROR('Do not specify the database name. Be in the required database and just specify the table name.',16,1)
 RETURN -1 --Failure. Reason: Database name is specified along with the table name, which is not allowed
 END


--Checking for the existence of 'user table' or 'view'
--This procedure is not written to work on system tables
--To script the data in system tables, just create a view on the system tables and script the view instead
IF @schema IS NULL
 BEGIN
 IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = @table_name AND (TABLE_TYPE = 'BASE TABLE' OR TABLE_TYPE = 'VIEW') AND TABLE_SCHEMA = SCHEMA_NAME())
 BEGIN
 RAISERROR('User table or view not found.',16,1)
 PRINT 'You may see this error if the specified table is not in your default schema (' + SCHEMA_NAME() + '). In that case use @schema parameter to specify the schema name.'
 PRINT 'Make sure you have SELECT permission on that table or view.'
 RETURN -1 --Failure. Reason: There is no user table or view with this name
 END
 END
ELSE
 BEGIN
 IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = @table_name AND (TABLE_TYPE = 'BASE TABLE' OR TABLE_TYPE = 'VIEW') AND TABLE_SCHEMA = @schema)
 BEGIN
 RAISERROR('User table or view not found.',16,1)
 PRINT 'Make sure you have SELECT permission on that table or view.'
 RETURN -1 --Failure. Reason: There is no user table or view with this name 
 END
 END


--Variable declarations
DECLARE @Column_ID int, 
 @Column_List varchar(max), 
 @Column_List_For_Update varchar(max), 
 @Column_List_For_Check varchar(max), 
 @Column_Name varchar(128), 
 @Column_Name_Unquoted varchar(128), 
 @Data_Type varchar(128), 
 @Actual_Values nvarchar(max), --This is the string that will be finally executed to generate a MERGE statement
 @IDN varchar(128), --Will contain the IDENTITY column's name in the table
 @Target_Table_For_Output varchar(776),
 @Source_Table_Qualified varchar(776)
 
 

--Variable Initialization
SET @IDN = ''
SET @Column_ID = 0
SET @Column_Name = ''
SET @Column_Name_Unquoted = ''
SET @Column_List = ''
SET @Column_List_For_Update = ''
SET @Column_List_For_Check = ''
SET @Actual_Values = ''

--Variable Defaults
IF @target_table IS NOT NULL AND (@target_table LIKE '%.%' OR @target_table LIKE '\[%\]' ESCAPE '\')
BEGIN
 IF NOT @target_table LIKE '\[%\]' ESCAPE '\'
 BEGIN
  RAISERROR('Ambiguous value for @target_table specified. Use QUOTENAME() to ensure the identifer is fully qualified (e.g. [dbo].[Titles] or [OtherDb].[dbo].[Titles]).',16,1)
  RETURN -1 --Failure. Reason: The value could be a multi-part object identifier or it could be a single-part object identifier that just happens to include a period character
 END

 -- If the user has specified the @schema param, but the qualified @target_table they've specified does not include the target schema, then fail validation to avoid any ambiguity
 IF @schema IS NOT NULL AND @target_table NOT LIKE '%.%'
 BEGIN
  RAISERROR('The specified @target_table is missing a schema name (e.g. [dbo].[Titles]).',16,1)
  RETURN -1 --Failure. Reason: Omitting the schema in this scenario is likely a mistake
 END

 SET @Target_Table_For_Output = @target_table 
END
ELSE
BEGIN
 IF @schema IS NULL
 BEGIN
  SET @Target_Table_For_Output = QUOTENAME(COALESCE(@target_table, @table_name))
 END
 ELSE
 BEGIN
  SET @Target_Table_For_Output = QUOTENAME(@schema) + '.' + QUOTENAME(COALESCE(@target_table, @table_name))
 END
END

SET @Source_Table_Qualified = QUOTENAME(COALESCE(@schema,SCHEMA_NAME())) + '.' + QUOTENAME(@table_name)

--To get the first column's ID
SELECT @Column_ID = MIN(ORDINAL_POSITION) 
FROM INFORMATION_SCHEMA.COLUMNS (NOLOCK) 
WHERE TABLE_NAME = @table_name
AND TABLE_SCHEMA = COALESCE(@schema, SCHEMA_NAME())


--Loop through all the columns of the table, to get the column names and their data types
WHILE @Column_ID IS NOT NULL
 BEGIN
 SELECT @Column_Name = QUOTENAME(COLUMN_NAME), 
 @Column_Name_Unquoted = COLUMN_NAME,
 @Data_Type = DATA_TYPE 
 FROM INFORMATION_SCHEMA.COLUMNS (NOLOCK) 
 WHERE ORDINAL_POSITION = @Column_ID
 AND TABLE_NAME = @table_name
 AND TABLE_SCHEMA = COALESCE(@schema, SCHEMA_NAME())


IF @Data_Type IN ('timestamp','rowversion') --SQL Server doesn't allow Timestamp/Rowversion column updates
BEGIN
	GOTO SKIP_LOOP
END

 IF @cols_to_include IS NOT NULL --Selecting only user specified columns
 BEGIN
 IF CHARINDEX( '''' + SUBSTRING(@Column_Name,2,LEN(@Column_Name)-2) + '''',@cols_to_include) = 0 
 BEGIN
 GOTO SKIP_LOOP
 END
 END

 IF @cols_to_exclude IS NOT NULL --Selecting only user specified columns
 BEGIN
 IF CHARINDEX( '''' + SUBSTRING(@Column_Name,2,LEN(@Column_Name)-2) + '''',@cols_to_exclude) <> 0 
 BEGIN
 GOTO SKIP_LOOP
 END
 END

 --Making sure to output SET IDENTITY_INSERT ON/OFF in case the table has an IDENTITY column
 IF (SELECT COLUMNPROPERTY( OBJECT_ID(@Source_Table_Qualified),SUBSTRING(@Column_Name,2,LEN(@Column_Name) - 2),'IsIdentity')) = 1 
 BEGIN
 IF @ommit_identity = 0 --Determing whether to include or exclude the IDENTITY column
 SET @IDN = @Column_Name
 ELSE
 GOTO SKIP_LOOP 
 END
 
 --Making sure whether to output computed columns or not
 IF @ommit_computed_cols = 1
 BEGIN
 IF (SELECT COLUMNPROPERTY( OBJECT_ID(@Source_Table_Qualified),SUBSTRING(@Column_Name,2,LEN(@Column_Name) - 2),'IsComputed')) = 1 
 BEGIN
 PRINT 'Warning: The ' + @Column_Name + ' computed column will be excluded from the MERGE statement. Specify @ommit_computed_cols = 0 to include computed columns.'
 GOTO SKIP_LOOP 
 END
 END
 
 --Tables with columns of IMAGE data type are not supported for obvious reasons
 IF(@Data_Type in ('image'))
 BEGIN
 IF (@ommit_images = 0)
 BEGIN
 RAISERROR('Tables with image columns are not supported.',16,1)
 PRINT 'Use @ommit_images = 1 parameter to generate a MERGE for the rest of the columns.'
 RETURN -1 --Failure. Reason: There is a column with image data type
 END
 ELSE
 BEGIN
 GOTO SKIP_LOOP
 END
 END

 --Determining the data type of the column and depending on the data type, the VALUES part of
 --the MERGE statement is generated. Care is taken to handle columns with NULL values. Also
 --making sure, not to lose any data from flot, real, money, smallmomey, datetime columns
 SET @Actual_Values = @Actual_Values +
 CASE 
 WHEN @Data_Type IN ('char','nchar') 
 THEN 
 'COALESCE(''N'''''' + REPLACE(RTRIM(' + @Column_Name + '),'''''''','''''''''''')+'''''''',''NULL'')'
 WHEN @Data_Type IN ('varchar','nvarchar') 
 THEN 
 'COALESCE(''N'''''' + REPLACE(' + @Column_Name + ','''''''','''''''''''')+'''''''',''NULL'')'
 WHEN @Data_Type IN ('datetime','smalldatetime','datetime2','date', 'datetimeoffset') 
 THEN 
 'COALESCE('''''''' + RTRIM(CONVERT(char,' + @Column_Name + ',127))+'''''''',''NULL'')'
 WHEN @Data_Type IN ('uniqueidentifier') 
 THEN 
 'COALESCE(''N'''''' + REPLACE(CONVERT(char(36),RTRIM(' + @Column_Name + ')),'''''''','''''''''''')+'''''''',''NULL'')'
 WHEN @Data_Type IN ('text') 
 THEN 
 'COALESCE(''N'''''' + REPLACE(CONVERT(varchar(max),' + @Column_Name + '),'''''''','''''''''''')+'''''''',''NULL'')' 
 WHEN @Data_Type IN ('ntext') 
 THEN 
 'COALESCE('''''''' + REPLACE(CONVERT(nvarchar(max),' + @Column_Name + '),'''''''','''''''''''')+'''''''',''NULL'')' 
 WHEN @Data_Type IN ('xml') 
 THEN 
 'COALESCE('''''''' + REPLACE(CONVERT(nvarchar(max),' + @Column_Name + '),'''''''','''''''''''')+'''''''',''NULL'')' 
 WHEN @Data_Type IN ('binary','varbinary') 
 THEN 
 'COALESCE(RTRIM(CONVERT(varchar(max),' + @Column_Name + ', 1)),''NULL'')' 
 WHEN @Data_Type IN ('float','real','money','smallmoney')
 THEN
 'COALESCE(LTRIM(RTRIM(' + 'CONVERT(char, ' + @Column_Name + ',2)' + ')),''NULL'')' 
 WHEN @Data_Type IN ('hierarchyid')
 THEN 
  'COALESCE(''hierarchyid::Parse(''+'''''''' + LTRIM(RTRIM(' + 'CONVERT(char, ' + @Column_Name + ')' + '))+''''''''+'')'',''NULL'')' 
 WHEN @Data_Type IN ('geography')
 THEN
  'COALESCE(''geography::STGeomFromText(''+'''''''' + LTRIM(RTRIM(' + 'CONVERT(nvarchar(max),' + @Column_Name + ')' + '))+''''''''+'', 4326)'',''NULL'')' 
 WHEN @Data_Type IN ('geometry')
 THEN
  'COALESCE(''geometry::Parse(''+'''''''' + LTRIM(RTRIM(' + 'CONVERT(nvarchar(max),' + @Column_Name + ')' + '))+''''''''+'')'',''NULL'')' 
 ELSE 
 'COALESCE(LTRIM(RTRIM(' + 'CONVERT(char, ' + @Column_Name + ')' + ')),''NULL'')' 
 END + '+' + ''',''' + ' + '
 
 --Generating the column list for the MERGE statement
 SET @Column_List = @Column_List + @Column_Name + ',' 
 
 --Don't update Primary Key or Identity columns
 IF NOT EXISTS(
 SELECT 1
 FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS pk ,
 INFORMATION_SCHEMA.KEY_COLUMN_USAGE c
 WHERE pk.TABLE_NAME = @table_name
 AND pk.TABLE_SCHEMA = COALESCE(@schema, SCHEMA_NAME())
 AND CONSTRAINT_TYPE = 'PRIMARY KEY'
 AND c.TABLE_NAME = pk.TABLE_NAME
 AND c.TABLE_SCHEMA = pk.TABLE_SCHEMA
 AND c.CONSTRAINT_NAME = pk.CONSTRAINT_NAME
 AND c.COLUMN_NAME = @Column_Name_Unquoted 
 )
 BEGIN
 SET @Column_List_For_Update = @Column_List_For_Update + @Column_Name + ' = [Source].' + @Column_Name + ', 
  ' 
 SET @Column_List_For_Check = @Column_List_For_Check +
 CASE @Data_Type 
 WHEN 'text' THEN CHAR(10) + CHAR(9) + 'NULLIF(CAST([Source].' + @Column_Name + ' AS VARCHAR(MAX)), CAST([Target].' + @Column_Name + ' AS VARCHAR(MAX))) IS NOT NULL OR NULLIF(CAST([Target].' + @Column_Name + ' AS VARCHAR(MAX)), CAST([Source].' + @Column_Name + ' AS VARCHAR(MAX))) IS NOT NULL OR '
 WHEN 'ntext' THEN CHAR(10) + CHAR(9) + 'NULLIF(CAST([Source].' + @Column_Name + ' AS NVARCHAR(MAX)), CAST([Target].' + @Column_Name + ' AS NVARCHAR(MAX))) IS NOT NULL OR NULLIF(CAST([Target].' + @Column_Name + ' AS NVARCHAR(MAX)), CAST([Source].' + @Column_Name + ' AS NVARCHAR(MAX))) IS NOT NULL OR ' 
 WHEN 'geography' THEN CHAR(10) + CHAR(9) + '((NOT ([Source].' + @Column_Name + ' IS NULL AND [Target].' + @Column_Name + ' IS NULL)) AND ISNULL(ISNULL([Source].' + @Column_Name + ', geography::[Null]).STEquals([Target].' + @Column_Name + '), 0) = 0) OR '
 WHEN 'geometry' THEN CHAR(10) + CHAR(9) + '((NOT ([Source].' + @Column_Name + ' IS NULL AND [Target].' + @Column_Name + ' IS NULL)) AND ISNULL(ISNULL([Source].' + @Column_Name + ', geometry::[Null]).STEquals([Target].' + @Column_Name + '), 0) = 0) OR '
 ELSE CHAR(10) + CHAR(9) + 'NULLIF([Source].' + @Column_Name + ', [Target].' + @Column_Name + ') IS NOT NULL OR NULLIF([Target].' + @Column_Name + ', [Source].' + @Column_Name + ') IS NOT NULL OR '
 END 
 END

 SKIP_LOOP: --The label used in GOTO

 SELECT @Column_ID = MIN(ORDINAL_POSITION) 
 FROM INFORMATION_SCHEMA.COLUMNS (NOLOCK) 
 WHERE TABLE_NAME = @table_name
 AND TABLE_SCHEMA = COALESCE(@schema, SCHEMA_NAME())
 AND ORDINAL_POSITION > @Column_ID

 END --Loop ends here!


--To get rid of the extra characters that got concatenated during the last run through the loop
IF LEN(@Column_List_For_Update) <> 0
 BEGIN
 SET @Column_List_For_Update = ' ' + LEFT(@Column_List_For_Update,len(@Column_List_For_Update) - 4)
 END

IF LEN(@Column_List_For_Check) <> 0
 BEGIN
 SET @Column_List_For_Check = LEFT(@Column_List_For_Check,len(@Column_List_For_Check) - 3)
 END

SET @Actual_Values = LEFT(@Actual_Values,len(@Actual_Values) - 6)

SET @Column_List = LEFT(@Column_List,len(@Column_List) - 1)
IF LEN(LTRIM(@Column_List)) = 0
 BEGIN
 RAISERROR('No columns to select. There should at least be one column to generate the output',16,1)
 RETURN -1 --Failure. Reason: Looks like all the columns are ommitted using the @cols_to_exclude parameter
 END


--Get the join columns ----------------------------------------------------------
DECLARE @PK_column_list VARCHAR(max)
DECLARE @PK_column_joins VARCHAR(max)
SET @PK_column_list = ''
SET @PK_column_joins = ''

IF ISNULL(@cols_to_join_on, '') = '' -- Use primary key of the source table as the basis of MERGE joins, if no join list is specified
BEGIN
	SELECT @PK_column_list = @PK_column_list + '[' + c.COLUMN_NAME + '], '
	, @PK_column_joins = @PK_column_joins + '[Target].[' + c.COLUMN_NAME + '] = [Source].[' + c.COLUMN_NAME + '] AND '
	FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS pk ,
	INFORMATION_SCHEMA.KEY_COLUMN_USAGE c
	WHERE pk.TABLE_NAME = @table_name
	AND pk.TABLE_SCHEMA = COALESCE(@schema, SCHEMA_NAME())
	AND CONSTRAINT_TYPE = 'PRIMARY KEY'
	AND c.TABLE_NAME = pk.TABLE_NAME
	AND c.TABLE_SCHEMA = pk.TABLE_SCHEMA
	AND c.CONSTRAINT_NAME = pk.CONSTRAINT_NAME
END
ELSE
BEGIN
	SELECT @PK_column_list = @PK_column_list + '[' + c.COLUMN_NAME + '], '
	, @PK_column_joins = @PK_column_joins + '[Target].[' + c.COLUMN_NAME + '] = [Source].[' + c.COLUMN_NAME + '] AND '
	FROM INFORMATION_SCHEMA.COLUMNS AS c
	WHERE @cols_to_join_on LIKE '%''' + c.COLUMN_NAME + '''%'
	AND c.TABLE_NAME = @table_name
	AND c.TABLE_SCHEMA = COALESCE(@schema, SCHEMA_NAME())
END

IF ISNULL(@PK_column_list, '') = '' 
BEGIN
	RAISERROR('Table does not have a primary key from which to generate the join clause(s) and/or a valid @cols_to_join_on has not been specified. Either add a primary key/composite key to the table or specify the @cols_to_join_on parameter.',16,1)
	RETURN -1 --Failure. Reason: looks like table doesn't have any primary keys
END

SET @PK_column_list = LEFT(@PK_column_list, LEN(@PK_column_list) -1)
SET @PK_column_joins = LEFT(@PK_column_joins, LEN(@PK_column_joins) -4)


--Forming the final string that will be executed, to output the a MERGE statement
SET @Actual_Values = 
 'SELECT ' + 
 CASE WHEN @top IS NULL OR @top < 0 THEN '' ELSE ' TOP ' + LTRIM(STR(@top)) + ' ' END + 
 '''' + 
 ' '' + CASE WHEN ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) = 1 THEN '' '' ELSE '','' END + ''(''+ ' + @Actual_Values + '+'')''' + ' ' + 
 COALESCE(@from,' FROM ' + @Source_Table_Qualified + ' (NOLOCK) ORDER BY ' + @PK_column_list)

 DECLARE @output NVARCHAR(MAX) = ''
 DECLARE @b CHAR(1) = CHAR(13)

--Determining whether to ouput any debug information
IF @debug_mode =1
 BEGIN
 SET @output += @b + '/*****START OF DEBUG INFORMATION*****'
 SET @output += @b + ''
 SET @output += @b + 'The primary key column list:'
 SET @output += @b + @PK_column_list
 SET @output += @b + ''
 SET @output += @b + 'The INSERT column list:'
 SET @output += @b + @Column_List
 SET @output += @b + ''
 SET @output += @b + 'The UPDATE column list:'
 SET @output += @b + @Column_List_For_Update
 SET @output += @b + ''
 SET @output += @b + 'The SELECT statement executed to generate the MERGE:'
 SET @output += @b + @Actual_Values
 SET @output += @b + ''
 SET @output += @b + '*****END OF DEBUG INFORMATION*****/'
 SET @output += @b + ''
 END
 
IF (@include_use_db = 1)
BEGIN
	SET @output += 'USE [' + DB_NAME() + ']'
	SET @output += @b + @batch_separator
	SET @output += @b + @b
END

IF (@nologo = 0)
BEGIN
 SET @output += @b + '--MERGE generated by ''sp_generate_merge'' stored procedure'
 SET @output += @b + '--Originally by Vyas (http://vyaskn.tripod.com/code): sp_generate_inserts (build 22)'
 SET @output += @b + '--Adapted for SQL Server 2008+ by Daniel Nolan (https://twitter.com/dnlnln)'
 SET @output += @b + ''
END

IF (@include_rowsaffected = 1) -- If the caller has elected not to include the "rows affected" section, let MERGE output the row count as it is executed.
 SET @output += @b + 'SET NOCOUNT ON'
 SET @output += @b + ''


--Determining whether to print IDENTITY_INSERT or not
IF (LEN(@IDN) <> 0)
 BEGIN
 SET @output += @b + 'SET IDENTITY_INSERT ' + @Target_Table_For_Output + ' ON'
 SET @output += @b + ''
 END


--Temporarily disable constraints on the target table
IF @disable_constraints = 1 AND (OBJECT_ID(@Source_Table_Qualified, 'U') IS NOT NULL)
 BEGIN
 SET @output += @b + 'ALTER TABLE ' + @Target_Table_For_Output + ' NOCHECK CONSTRAINT ALL' --Code to disable constraints temporarily
 END


--Output the start of the MERGE statement, qualifying with the schema name only if the caller explicitly specified it
SET @output += @b + 'MERGE INTO ' + @Target_Table_For_Output + ' AS [Target]'

IF @include_values = 1
BEGIN
 SET @output += @b + 'USING ('
 --All the hard work pays off here!!! You'll get your MERGE statement, when the next line executes!
 DECLARE @tab TABLE (ID INT NOT NULL PRIMARY KEY IDENTITY(1,1), val NVARCHAR(max));
 INSERT INTO @tab (val)
 EXEC (@Actual_Values)

 IF (SELECT COUNT(*) FROM @tab) <> 0 -- Ensure that rows were returned, otherwise the MERGE statement will get nullified.
 BEGIN
  SET @output += 'VALUES' + CAST((SELECT @b + val FROM @tab ORDER BY ID FOR XML PATH('')) AS XML).value('.', 'NVARCHAR(MAX)');
 END
 ELSE
 BEGIN
  -- Mimic an empty result set by returning zero rows from the target table
  SET @output += 'SELECT ' + @Column_List + ' FROM ' + @Target_Table_For_Output + ' WHERE 1 = 0 -- Empty dataset (source table contained no rows at time of MERGE generation) '
 END

 --Output the columns to correspond with each of the values above--------------------
 SET @output += @b + ') AS [Source] (' + @Column_List + ')'
END
ELSE
 BEGIN
  SET @output += @b + 'USING ' + @Source_Table_Qualified + ' AS [Source]';
 END

--Output the join columns ----------------------------------------------------------
SET @output += @b + 'ON (' + @PK_column_joins + ')'


--When matched, perform an UPDATE on any metadata columns only (ie. not on PK)------
IF LEN(@Column_List_For_Update) <> 0
BEGIN
 SET @output += @b + 'WHEN MATCHED ' + CASE WHEN @update_only_if_changed = 1 THEN 'AND (' + @Column_List_For_Check + ') ' ELSE '' END + 'THEN'
 SET @output += @b + ' UPDATE SET'
 SET @output += @b + '  ' + LTRIM(@Column_List_For_Update)
END


--When NOT matched by target, perform an INSERT------------------------------------
SET @output += @b + 'WHEN NOT MATCHED BY TARGET THEN';
SET @output += @b + ' INSERT(' + @Column_List + ')'
SET @output += @b + ' VALUES(' + REPLACE(@Column_List, '[', '[Source].[') + ')'


--When NOT matched by source, DELETE the row
IF @delete_if_not_matched=1 BEGIN
 SET @output += @b + 'WHEN NOT MATCHED BY SOURCE THEN '
 SET @output += @b + ' DELETE'
END;
SET @output += @b + ';'
SET @output += @b + @batch_separator

--Display the number of affected rows to the user, or report if an error occurred---
IF @include_rowsaffected = 1
BEGIN
 SET @output += @b + 'DECLARE @mergeError int'
 SET @output += @b + ' , @mergeCount int'
 SET @output += @b + 'SELECT @mergeError = @@ERROR, @mergeCount = @@ROWCOUNT'
 SET @output += @b + 'IF @mergeError != 0'
 SET @output += @b + ' BEGIN'
 SET @output += @b + ' PRINT ''ERROR OCCURRED IN MERGE FOR ' + @Target_Table_For_Output + '. Rows affected: '' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected';
 SET @output += @b + ' END'
 SET @output += @b + 'ELSE'
 SET @output += @b + ' BEGIN'
 SET @output += @b + ' PRINT ''' + @Target_Table_For_Output + ' rows affected by MERGE: '' + CAST(@mergeCount AS VARCHAR(100));';
 SET @output += @b + ' END'
 SET @output += @b + @batch_separator
 SET @output += @b + @b
END

--Re-enable the previously disabled constraints-------------------------------------
IF @disable_constraints = 1 AND (OBJECT_ID(@Source_Table_Qualified, 'U') IS NOT NULL)
 BEGIN
 SET @output +=      'ALTER TABLE ' + @Target_Table_For_Output + ' CHECK CONSTRAINT ALL' --Code to enable the previously disabled constraints
 SET @output += @b + @batch_separator
 SET @output += @b
 END


--Switch-off identity inserting------------------------------------------------------
IF (LEN(@IDN) <> 0)
 BEGIN
 SET @output +=      'SET IDENTITY_INSERT ' + @Target_Table_For_Output + ' OFF'
 SET @output += @b + @batch_separator
 SET @output += @b
 END

IF (@include_rowsaffected = 1)
BEGIN
 SET @output +=      'SET NOCOUNT OFF'
 SET @output += @b + @batch_separator
 SET @output += @b
END

SET @output += @b + ''
SET @output += @b + ''

IF @results_to_text = 1
BEGIN
	--output the statement to the Grid/Messages tab
	SELECT @output;
END
ELSE
BEGIN
	--output the statement as xml (to overcome SSMS 4000/8000 char limitation)
	SELECT [processing-instruction(x)]=@output FOR XML PATH(''),TYPE;
	PRINT 'MERGE statement has been wrapped in an XML fragment and output successfully.'
	PRINT 'Ensure you have Results to Grid enabled and then click the hyperlink to copy the statement within the fragment.'
	PRINT ''
	PRINT 'If you would prefer to have results output directly (without XML) specify @results_to_text = 1, however please'
	PRINT 'note that the results may be truncated by your SQL client to 4000 nchars.'
END

SET NOCOUNT OFF
RETURN 0 --Success. We are done!
END
GO
PRINT N'Creating [dbo].[tg_Case_GetNumberCase]...';


GO
CREATE TRIGGER [dbo].[tg_Case_GetNumberCase]
ON dbo.[Case] INSTEAD OF INSERT
NOT FOR REPLICATION
AS
BEGIN
SET NOCOUNT ON;
	 BEGIN
	 DECLARE @NumberCase INT
	 DECLARE @BusinessUnitId INT = (SELECT TOP 1 [BusinessUnitId] FROM inserted);
	 EXEC dbo.GetNumber 'CaseNumber',@BusinessUnitId, @NumberCase OUTPUT;
      INSERT INTO dbo.[Case] 
	  (
	  		[BusinessUnitId],
			[BranchOfficeId],
			[CaseTypeId],
			[CaseNumber],
			[StatusId],
			[RiskId],
			[AnalystId],
			[CreateDate],
			[UpdateFile],
			[ContactMail],
			[ContactAddress],
			[ContactZipCode],
			[ContactProvince],
			[ContactCity],
			[ContactStateId],
			[ProducerId],
			[PersonId],
			[OriginalPersonId],
			[Comment],
			[Value]
	  )
      SELECT 
			[BusinessUnitId],
			[BranchOfficeId],
			[CaseTypeId],
			@NumberCase,
			[StatusId],
			[RiskId],
			[AnalystId],
			[CreateDate],
			[UpdateFile],
			[ContactMail],
			[ContactAddress],
			[ContactZipCode],
			[ContactProvince],
			[ContactCity],
			[ContactStateId],
			[ProducerId],
			[PersonId],
			[OriginalPersonId],
			[Comment],
			[Value]
      FROM   Inserted
	 END
END
GO
-- Refactoring step to update target server with deployed transaction logs

IF OBJECT_ID(N'dbo.__RefactorLog') IS NULL
BEGIN
    CREATE TABLE [dbo].[__RefactorLog] (OperationKey UNIQUEIDENTIFIER NOT NULL PRIMARY KEY)
    EXEC sp_addextendedproperty N'microsoft_database_tools_support', N'refactoring log', N'schema', N'dbo', N'table', N'__RefactorLog'
END
GO
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '9365d329-d0bb-493b-a296-8bd8d4840c49')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('9365d329-d0bb-493b-a296-8bd8d4840c49')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '030707a2-5d9f-4367-8d3a-c6dc9582d009')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('030707a2-5d9f-4367-8d3a-c6dc9582d009')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'b469e449-83fe-4bbd-8c29-97f73dbe08c5')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('b469e449-83fe-4bbd-8c29-97f73dbe08c5')

GO

GO
GO


--MERGE generated by 'sp_generate_merge' stored procedure
--Originally by Vyas (http://vyaskn.tripod.com/code): sp_generate_inserts (build 22)
--Adapted for SQL Server 2008+ by Daniel Nolan (https://twitter.com/dnlnln)

SET NOCOUNT ON

SET IDENTITY_INSERT [Country] ON

MERGE INTO [Country] AS [Target]
USING (VALUES
  (1,N'Argentina')
) AS [Source] ([CountryId],[Description])
ON ([Target].[CountryId] = [Source].[CountryId])
WHEN MATCHED AND (
	NULLIF([Source].[Description], [Target].[Description]) IS NOT NULL OR NULLIF([Target].[Description], [Source].[Description]) IS NOT NULL) THEN
 UPDATE SET
  [Description] = [Source].[Description]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([CountryId],[Description])
 VALUES([Source].[CountryId],[Source].[Description])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
;
GO
DECLARE @mergeError int
 , @mergeCount int
SELECT @mergeError = @@ERROR, @mergeCount = @@ROWCOUNT
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [Country]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[Country] rows affected by MERGE: ' + CAST(@mergeCount AS VARCHAR(100));
 END
GO

SET IDENTITY_INSERT [Country] OFF
GO
SET NOCOUNT OFF
GO
SET NOCOUNT ON

SET IDENTITY_INSERT [State] ON

MERGE INTO [State] AS [Target]
USING (VALUES
  (1,N'Santa Fe',1)
 ,(2,N'Buenos Aires',1)
) AS [Source] ([StateId],[Description],[CountryId])
ON ([Target].[StateId] = [Source].[StateId])
WHEN MATCHED AND (
	NULLIF([Source].[Description], [Target].[Description]) IS NOT NULL OR NULLIF([Target].[Description], [Source].[Description]) IS NOT NULL OR 
	NULLIF([Source].[CountryId], [Target].[CountryId]) IS NOT NULL OR NULLIF([Target].[CountryId], [Source].[CountryId]) IS NOT NULL) THEN
 UPDATE SET
  [Description] = [Source].[Description], 
  [CountryId] = [Source].[CountryId]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([StateId],[Description],[CountryId])
 VALUES([Source].[StateId],[Source].[Description],[Source].[CountryId])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
;
GO
DECLARE @mergeError int
 , @mergeCount int
SELECT @mergeError = @@ERROR, @mergeCount = @@ROWCOUNT
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [State]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[State] rows affected by MERGE: ' + CAST(@mergeCount AS VARCHAR(100));
 END
GO

SET IDENTITY_INSERT [State] OFF
GO
SET NOCOUNT OFF
GO

SET NOCOUNT ON

SET IDENTITY_INSERT [Location] ON

MERGE INTO [Location] AS [Target]
USING (VALUES
  (4,N'Arroyo Seco',1,2128)
 ,(5,N'Rosario',1,2000)
) AS [Source] ([LocationId],[Description],[StateId],[ZipCode])
ON ([Target].[LocationId] = [Source].[LocationId])
WHEN MATCHED AND (
	NULLIF([Source].[Description], [Target].[Description]) IS NOT NULL OR NULLIF([Target].[Description], [Source].[Description]) IS NOT NULL OR 
	NULLIF([Source].[StateId], [Target].[StateId]) IS NOT NULL OR NULLIF([Target].[StateId], [Source].[StateId]) IS NOT NULL OR 
	NULLIF([Source].[ZipCode], [Target].[ZipCode]) IS NOT NULL OR NULLIF([Target].[ZipCode], [Source].[ZipCode]) IS NOT NULL) THEN
 UPDATE SET
  [Description] = [Source].[Description], 
  [StateId] = [Source].[StateId], 
  [ZipCode] = [Source].[ZipCode]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([LocationId],[Description],[StateId],[ZipCode])
 VALUES([Source].[LocationId],[Source].[Description],[Source].[StateId],[Source].[ZipCode])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
;
GO
DECLARE @mergeError int
 , @mergeCount int
SELECT @mergeError = @@ERROR, @mergeCount = @@ROWCOUNT
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [Location]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[Location] rows affected by MERGE: ' + CAST(@mergeCount AS VARCHAR(100));
 END
GO

SET IDENTITY_INSERT [Location] OFF
GO
SET NOCOUNT OFF
GO
SET NOCOUNT ON

SET IDENTITY_INSERT [Status] ON

MERGE INTO [Status] AS [Target]
USING (VALUES
  (1,N'Nuevo',0,7,2)
 ,(2,N'Falso Positivo',1,7,2)
 ,(3,N'Desestimado',1,7,2)
 ,(4,N'Finalizado',1,7,2)
 ,(5,N'Cancelado',1,7,2)
 ,(6,N'Asignado Analista',0,7,2)
 ,(7,N'Información Requerida',0,7,2)
 ,(8,N'Información Recibida',0,7,2)
 ,(9,N'Asignado a Oficilia de Cumplimiento',0,7,2)
 ,(10,N'Asignado Superior',0,7,2)
) AS [Source] ([StatusId],[Description],[Finisher],[DefaultExpiration],[WarningDays])
ON ([Target].[StatusId] = [Source].[StatusId])
WHEN MATCHED AND (
	NULLIF([Source].[Description], [Target].[Description]) IS NOT NULL OR NULLIF([Target].[Description], [Source].[Description]) IS NOT NULL OR 
	NULLIF([Source].[Finisher], [Target].[Finisher]) IS NOT NULL OR NULLIF([Target].[Finisher], [Source].[Finisher]) IS NOT NULL OR 
	NULLIF([Source].[DefaultExpiration], [Target].[DefaultExpiration]) IS NOT NULL OR NULLIF([Target].[DefaultExpiration], [Source].[DefaultExpiration]) IS NOT NULL OR 
	NULLIF([Source].[WarningDays], [Target].[WarningDays]) IS NOT NULL OR NULLIF([Target].[WarningDays], [Source].[WarningDays]) IS NOT NULL) THEN
 UPDATE SET
  [Description] = [Source].[Description], 
  [Finisher] = [Source].[Finisher], 
  [DefaultExpiration] = [Source].[DefaultExpiration], 
  [WarningDays] = [Source].[WarningDays]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([StatusId],[Description],[Finisher],[DefaultExpiration],[WarningDays])
 VALUES([Source].[StatusId],[Source].[Description],[Source].[Finisher],[Source].[DefaultExpiration],[Source].[WarningDays])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
;
GO
DECLARE @mergeError int
 , @mergeCount int
SELECT @mergeError = @@ERROR, @mergeCount = @@ROWCOUNT
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [Status]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[Status] rows affected by MERGE: ' + CAST(@mergeCount AS VARCHAR(100));
 END
GO

SET IDENTITY_INSERT [Status] OFF
GO
SET NOCOUNT OFF
GO
SET NOCOUNT ON

SET IDENTITY_INSERT [BranchOffice] ON

MERGE INTO [BranchOffice] AS [Target]
USING (VALUES
  (1,N'Arroyo Seco',N'sucursal@mail.com',N'San Martin 840',1,1,2128),
(2,N'Perez',N'sucursalperez@mail.com',N'Alberdi 840',1,1,2128)
) AS [Source] ([BranchOfficeId],[Description],[Mail],[Address],[StateId],[CountryId],[ZipCode])
ON ([Target].[BranchOfficeId] = [Source].[BranchOfficeId])
WHEN MATCHED AND (
	NULLIF([Source].[Description], [Target].[Description]) IS NOT NULL OR NULLIF([Target].[Description], [Source].[Description]) IS NOT NULL OR 
	NULLIF([Source].[Mail], [Target].[Mail]) IS NOT NULL OR NULLIF([Target].[Mail], [Source].[Mail]) IS NOT NULL OR 
	NULLIF([Source].[Address], [Target].[Address]) IS NOT NULL OR NULLIF([Target].[Address], [Source].[Address]) IS NOT NULL OR 
	NULLIF([Source].[StateId], [Target].[StateId]) IS NOT NULL OR NULLIF([Target].[StateId], [Source].[StateId]) IS NOT NULL OR 
	NULLIF([Source].[CountryId], [Target].[CountryId]) IS NOT NULL OR NULLIF([Target].[CountryId], [Source].[CountryId]) IS NOT NULL OR 
	NULLIF([Source].[ZipCode], [Target].[ZipCode]) IS NOT NULL OR NULLIF([Target].[ZipCode], [Source].[ZipCode]) IS NOT NULL) THEN
 UPDATE SET
  [Description] = [Source].[Description], 
  [Mail] = [Source].[Mail], 
  [Address] = [Source].[Address], 
  [StateId] = [Source].[StateId], 
  [CountryId] = [Source].[CountryId], 
  [ZipCode] = [Source].[ZipCode]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([BranchOfficeId],[Description],[Mail],[Address],[StateId],[CountryId],[ZipCode])
 VALUES([Source].[BranchOfficeId],[Source].[Description],[Source].[Mail],[Source].[Address],[Source].[StateId],[Source].[CountryId],[Source].[ZipCode])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
;
GO
DECLARE @mergeError int
 , @mergeCount int
SELECT @mergeError = @@ERROR, @mergeCount = @@ROWCOUNT
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [BranchOffice]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[BranchOffice] rows affected by MERGE: ' + CAST(@mergeCount AS VARCHAR(100));
 END
GO

SET IDENTITY_INSERT [BranchOffice] OFF
GO
SET NOCOUNT OFF
GO
SET NOCOUNT ON

SET IDENTITY_INSERT [BusinessUnit] ON

MERGE INTO [BusinessUnit] AS [Target]
USING (VALUES
  (1,N'Seguros')
 ,(2,N'Retiro')
 ,(3,N'Iúnigo')
) AS [Source] ([BusinessUnitId],[Description])
ON ([Target].[BusinessUnitId] = [Source].[BusinessUnitId])
WHEN MATCHED AND (
	NULLIF([Source].[Description], [Target].[Description]) IS NOT NULL OR NULLIF([Target].[Description], [Source].[Description]) IS NOT NULL) THEN
 UPDATE SET
  [Description] = [Source].[Description]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([BusinessUnitId],[Description])
 VALUES([Source].[BusinessUnitId],[Source].[Description])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
;
GO
DECLARE @mergeError int
 , @mergeCount int
SELECT @mergeError = @@ERROR, @mergeCount = @@ROWCOUNT
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [BusinessUnit]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[BusinessUnit] rows affected by MERGE: ' + CAST(@mergeCount AS VARCHAR(100));
 END
GO

SET IDENTITY_INSERT [BusinessUnit] OFF
GO
SET NOCOUNT OFF
GO
SET NOCOUNT ON

SET IDENTITY_INSERT [Producer] ON

MERGE INTO [Producer] AS [Target]
USING (VALUES
  (1,1,N'Nahuel',N'nahuel@mail.com',N'abc123')
 ,(2,2,N'Emanuel',N'emanuel@mail.com',N'123abc')
) AS [Source] ([ProducerId],[BusinessUnitId],[ProduceName],[Mail],[OriginCode])
ON ([Target].[ProducerId] = [Source].[ProducerId])
WHEN MATCHED AND (
	NULLIF([Source].[BusinessUnitId], [Target].[BusinessUnitId]) IS NOT NULL OR NULLIF([Target].[BusinessUnitId], [Source].[BusinessUnitId]) IS NOT NULL OR 
	NULLIF([Source].[ProduceName], [Target].[ProduceName]) IS NOT NULL OR NULLIF([Target].[ProduceName], [Source].[ProduceName]) IS NOT NULL OR 
	NULLIF([Source].[Mail], [Target].[Mail]) IS NOT NULL OR NULLIF([Target].[Mail], [Source].[Mail]) IS NOT NULL OR 
	NULLIF([Source].[OriginCode], [Target].[OriginCode]) IS NOT NULL OR NULLIF([Target].[OriginCode], [Source].[OriginCode]) IS NOT NULL) THEN
 UPDATE SET
  [BusinessUnitId] = [Source].[BusinessUnitId], 
  [ProduceName] = [Source].[ProduceName], 
  [Mail] = [Source].[Mail], 
  [OriginCode] = [Source].[OriginCode]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([ProducerId],[BusinessUnitId],[ProduceName],[Mail],[OriginCode])
 VALUES([Source].[ProducerId],[Source].[BusinessUnitId],[Source].[ProduceName],[Source].[Mail],[Source].[OriginCode])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
;
GO
DECLARE @mergeError int
 , @mergeCount int
SELECT @mergeError = @@ERROR, @mergeCount = @@ROWCOUNT
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [Producer]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[Producer] rows affected by MERGE: ' + CAST(@mergeCount AS VARCHAR(100));
 END
GO

SET IDENTITY_INSERT [Producer] OFF
GO
SET NOCOUNT OFF
GO
SET NOCOUNT ON

SET IDENTITY_INSERT [Activity] ON

MERGE INTO [Activity] AS [Target]
USING (VALUES
  (1,N'Desarrollador de Software',0)
 ,(2,N'Analista de sistemas',0)
) AS [Source] ([ActivityId],[Description],[ObligatedSubject])
ON ([Target].[ActivityId] = [Source].[ActivityId])
WHEN MATCHED AND (
	NULLIF([Source].[Description], [Target].[Description]) IS NOT NULL OR NULLIF([Target].[Description], [Source].[Description]) IS NOT NULL OR 
	NULLIF([Source].[ObligatedSubject], [Target].[ObligatedSubject]) IS NOT NULL OR NULLIF([Target].[ObligatedSubject], [Source].[ObligatedSubject]) IS NOT NULL) THEN
 UPDATE SET
  [Description] = [Source].[Description], 
  [ObligatedSubject] = [Source].[ObligatedSubject]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([ActivityId],[Description],[ObligatedSubject])
 VALUES([Source].[ActivityId],[Source].[Description],[Source].[ObligatedSubject])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
;
GO
DECLARE @mergeError int
 , @mergeCount int
SELECT @mergeError = @@ERROR, @mergeCount = @@ROWCOUNT
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [Activity]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[Activity] rows affected by MERGE: ' + CAST(@mergeCount AS VARCHAR(100));
 END
GO

SET IDENTITY_INSERT [Activity] OFF
GO
SET NOCOUNT OFF
GO
SET NOCOUNT ON

SET IDENTITY_INSERT [CaseGroup] ON

MERGE INTO [CaseGroup] AS [Target]
USING (VALUES
  (1,N'Cambios de Condición')
 ,(2,N'Conozca a su Cliente')
 ,(3,N'Transaccionales')
) AS [Source] ([CaseGroupId],[Description])
ON ([Target].[CaseGroupId] = [Source].[CaseGroupId])
WHEN MATCHED AND (
	NULLIF([Source].[Description], [Target].[Description]) IS NOT NULL OR NULLIF([Target].[Description], [Source].[Description]) IS NOT NULL) THEN
 UPDATE SET
  [Description] = [Source].[Description]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([CaseGroupId],[Description])
 VALUES([Source].[CaseGroupId],[Source].[Description])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
;
GO
DECLARE @mergeError int
 , @mergeCount int
SELECT @mergeError = @@ERROR, @mergeCount = @@ROWCOUNT
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [CaseGroup]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[CaseGroup] rows affected by MERGE: ' + CAST(@mergeCount AS VARCHAR(100));
 END
GO

SET IDENTITY_INSERT [CaseGroup] OFF
GO
SET NOCOUNT OFF
GO

SET NOCOUNT ON

SET IDENTITY_INSERT [CaseType] ON

MERGE INTO [CaseType] AS [Target]
USING (VALUES
  (1,N'Nuevo Cliente',2)
 ,(2,N'Disminución del Riesgo',2)
 ,(3,N'Incremento del Riesgo',2)
 ,(4,N'Legajo Vencido',2)
 ,(5,N'Exceso en acumulado de pago de siniestros',3)
 ,(6,N'Exceso en acumulado de primas',3)
 ,(7,N'Operación de cliente incluido en lista gris',3)
 ,(8,N'Exceso en suma asegurada (vehículos de alta gama)',3)
 ,(9,N'Reintegro por cancelación de pólizas',3)
 ,(10,N'Cambio en la condición de PEP',1)
 ,(11,N'Cambio en la condición de Terrorista',1)
 ,(12,N'Sujeto Obligado no inscripto',1)
) AS [Source] ([CaseTypeId],[Description],[CaseGroupId])
ON ([Target].[CaseTypeId] = [Source].[CaseTypeId])
WHEN MATCHED AND (
	NULLIF([Source].[Description], [Target].[Description]) IS NOT NULL OR NULLIF([Target].[Description], [Source].[Description]) IS NOT NULL OR 
	NULLIF([Source].[CaseGroupId], [Target].[CaseGroupId]) IS NOT NULL OR NULLIF([Target].[CaseGroupId], [Source].[CaseGroupId]) IS NOT NULL) THEN
 UPDATE SET
  [Description] = [Source].[Description], 
  [CaseGroupId] = [Source].[CaseGroupId]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([CaseTypeId],[Description],[CaseGroupId])
 VALUES([Source].[CaseTypeId],[Source].[Description],[Source].[CaseGroupId])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
;
GO
DECLARE @mergeError int
 , @mergeCount int
SELECT @mergeError = @@ERROR, @mergeCount = @@ROWCOUNT
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [CaseType]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[CaseType] rows affected by MERGE: ' + CAST(@mergeCount AS VARCHAR(100));
 END
GO

SET IDENTITY_INSERT [CaseType] OFF
GO
SET NOCOUNT OFF
GO

SET NOCOUNT ON

SET IDENTITY_INSERT [DocumentType] ON

MERGE INTO [DocumentType] AS [Target]
USING (VALUES
  (1,N'Persona Juridica sin AG')
 ,(2,N'Persona Humana sin AG')
 ,(3,N'Persona Juridica con AG')
 ,(4,N'Persona Humana con AG')
) AS [Source] ([DocumentTypeId],[Description])
ON ([Target].[DocumentTypeId] = [Source].[DocumentTypeId])
WHEN MATCHED AND (
	NULLIF([Source].[Description], [Target].[Description]) IS NOT NULL OR NULLIF([Target].[Description], [Source].[Description]) IS NOT NULL) THEN
 UPDATE SET
  [Description] = [Source].[Description]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([DocumentTypeId],[Description])
 VALUES([Source].[DocumentTypeId],[Source].[Description])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
;
GO
DECLARE @mergeError int
 , @mergeCount int
SELECT @mergeError = @@ERROR, @mergeCount = @@ROWCOUNT
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [DocumentType]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[DocumentType] rows affected by MERGE: ' + CAST(@mergeCount AS VARCHAR(100));
 END
GO

SET IDENTITY_INSERT [DocumentType] OFF
GO
SET NOCOUNT OFF
GO

SET NOCOUNT ON

SET IDENTITY_INSERT [MailType] ON

MERGE INTO [MailType] AS [Target]
USING (VALUES
  (1,N'Persona Juridica sin AG',N'Persona Juridica sin AG',N'Persona Juridica sin AG')
 ,(2,N'Persona Humana sin AG',N'Persona Humana sin AG',N'Persona Humana sin AG')
 ,(3,N'Persona Juridica con AG',N'Persona Juridica con AG',N'Persona Juridica con AG')
 ,(4,N'Persona Humana con AG',N'Persona Humana con AG',N'Persona Humana con AG')
) AS [Source] ([MailTypeId],[Description],[Subject],[Message])
ON ([Target].[MailTypeId] = [Source].[MailTypeId])
WHEN MATCHED AND (
	NULLIF([Source].[Description], [Target].[Description]) IS NOT NULL OR NULLIF([Target].[Description], [Source].[Description]) IS NOT NULL OR 
	NULLIF([Source].[Subject], [Target].[Subject]) IS NOT NULL OR NULLIF([Target].[Subject], [Source].[Subject]) IS NOT NULL OR 
	NULLIF(CAST([Source].[Message] AS VARCHAR(MAX)), CAST([Target].[Message] AS VARCHAR(MAX))) IS NOT NULL OR NULLIF(CAST([Target].[Message] AS VARCHAR(MAX)), CAST([Source].[Message] AS VARCHAR(MAX))) IS NOT NULL) THEN
 UPDATE SET
  [Description] = [Source].[Description], 
  [Subject] = [Source].[Subject], 
  [Message] = [Source].[Message]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([MailTypeId],[Description],[Subject],[Message])
 VALUES([Source].[MailTypeId],[Source].[Description],[Source].[Subject],[Source].[Message])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
;
GO
DECLARE @mergeError int
 , @mergeCount int
SELECT @mergeError = @@ERROR, @mergeCount = @@ROWCOUNT
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [MailType]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[MailType] rows affected by MERGE: ' + CAST(@mergeCount AS VARCHAR(100));
 END
GO

SET IDENTITY_INSERT [MailType] OFF
GO
SET NOCOUNT OFF
GO


SET NOCOUNT ON

SET IDENTITY_INSERT [MessageType] ON

MERGE INTO [MessageType] AS [Target]
USING (VALUES
  (1,N'Error')
 ,(2,N'Warning')
 ,(3,N'Informacion')
 ,(4,N'Error Interno')
) AS [Source] ([MessageTypeId],[Description])
ON ([Target].[MessageTypeId] = [Source].[MessageTypeId])
WHEN MATCHED AND (
	NULLIF([Source].[Description], [Target].[Description]) IS NOT NULL OR NULLIF([Target].[Description], [Source].[Description]) IS NOT NULL) THEN
 UPDATE SET
  [Description] = [Source].[Description]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([MessageTypeId],[Description])
 VALUES([Source].[MessageTypeId],[Source].[Description])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
;
GO
DECLARE @mergeError int
 , @mergeCount int
SELECT @mergeError = @@ERROR, @mergeCount = @@ROWCOUNT
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [MessageType]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[MessageType] rows affected by MERGE: ' + CAST(@mergeCount AS VARCHAR(100));
 END
GO

SET IDENTITY_INSERT [MessageType] OFF
GO
SET NOCOUNT OFF
GO


SET NOCOUNT ON

SET IDENTITY_INSERT [NewsReasonType] ON

MERGE INTO [NewsReasonType] AS [Target]
USING (VALUES
  (1,N'Otro',1)
 ,(2,N'Analista asignado',1)
 ,(3,N'Reasignado por error',1)
 ,(4,N'Derivado por actitud sospechosa',1)
 ,(5,N'Caso finalizado',1)
 ,(6,N'Falso positivo',1)
 ,(7,N'Caso desestimado',1)
 ,(8,N'Se necesita más tiempo',1)
 ,(9,N'Analista debe continuar',1)
 ,(10,N'Se requiere información más detallada',1)
 ,(11,N'Información recibida',1)
) AS [Source] ([NewsReasonTypeId],[Description],[Global])
ON ([Target].[NewsReasonTypeId] = [Source].[NewsReasonTypeId])
WHEN MATCHED AND (
	NULLIF([Source].[Description], [Target].[Description]) IS NOT NULL OR NULLIF([Target].[Description], [Source].[Description]) IS NOT NULL OR 
	NULLIF([Source].[Global], [Target].[Global]) IS NOT NULL OR NULLIF([Target].[Global], [Source].[Global]) IS NOT NULL) THEN
 UPDATE SET
  [Description] = [Source].[Description], 
  [Global] = [Source].[Global]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([NewsReasonTypeId],[Description],[Global])
 VALUES([Source].[NewsReasonTypeId],[Source].[Description],[Source].[Global])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
;
GO
DECLARE @mergeError int
 , @mergeCount int
SELECT @mergeError = @@ERROR, @mergeCount = @@ROWCOUNT
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [NewsReasonType]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[NewsReasonType] rows affected by MERGE: ' + CAST(@mergeCount AS VARCHAR(100));
 END
GO

SET IDENTITY_INSERT [NewsReasonType] OFF
GO
SET NOCOUNT OFF
GO

SET NOCOUNT ON

SET IDENTITY_INSERT [NewsType] ON

MERGE INTO [NewsType] AS [Target]
USING (VALUES
  (1,N'Falso Positivo')
 ,(2,N'Desestimación')
 ,(3,N'Finalizacion')
 ,(4,N'Asignacion Analista')
 ,(5,N'Requerimiento Información')
 ,(6,N'Recibo Información')
 ,(7,N'Asignación Superior')
 ,(8,N'Asignación a Oficial de Cumplimiento')
 ,(9,N'Cierre por Nuevo Caso')
 ,(10,N'Cambio de Fecha de Vencimiento')
 ,(11,N'Reasignación de Analista')
 ,(12,N'Modificación del Riesgo')
 ,(13,N'Nueva Alerta')
 ,(14,N'Devolución')
) AS [Source] ([NewsTypeId],[Description])
ON ([Target].[NewsTypeId] = [Source].[NewsTypeId])
WHEN MATCHED AND (
	NULLIF([Source].[Description], [Target].[Description]) IS NOT NULL OR NULLIF([Target].[Description], [Source].[Description]) IS NOT NULL) THEN
 UPDATE SET
  [Description] = [Source].[Description]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([NewsTypeId],[Description])
 VALUES([Source].[NewsTypeId],[Source].[Description])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
;
GO
DECLARE @mergeError int
 , @mergeCount int
SELECT @mergeError = @@ERROR, @mergeCount = @@ROWCOUNT
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [NewsType]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[NewsType] rows affected by MERGE: ' + CAST(@mergeCount AS VARCHAR(100));
 END
GO

SET IDENTITY_INSERT [NewsType] OFF
GO
SET NOCOUNT OFF
GO
SET NOCOUNT ON

SET IDENTITY_INSERT [Processes] ON

MERGE INTO [Processes] AS [Target]
USING (VALUES
  (1,N'Calculo de Riesgo')
 ,(2,N'Vencimiento de Legajos')
) AS [Source] ([ProcessesId],[Description])
ON ([Target].[ProcessesId] = [Source].[ProcessesId])
WHEN MATCHED AND (
	NULLIF([Source].[Description], [Target].[Description]) IS NOT NULL OR NULLIF([Target].[Description], [Source].[Description]) IS NOT NULL) THEN
 UPDATE SET
  [Description] = [Source].[Description]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([ProcessesId],[Description])
 VALUES([Source].[ProcessesId],[Source].[Description])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
;
GO
DECLARE @mergeError int
 , @mergeCount int
SELECT @mergeError = @@ERROR, @mergeCount = @@ROWCOUNT
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [Processes]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[Processes] rows affected by MERGE: ' + CAST(@mergeCount AS VARCHAR(100));
 END
GO

SET IDENTITY_INSERT [Processes] OFF
GO
SET NOCOUNT OFF
GO
SET NOCOUNT ON

SET IDENTITY_INSERT [Setting] ON

MERGE INTO [Setting] AS [Target]
USING (VALUES
  (1,N'Ultima Sincronizacion Personas',NULL,NULL,NULL,NULL,NULL,0,NULL)
 ,(2,N'Ultima Sincronizacion Alertas',NULL,NULL,NULL,NULL,NULL,0,NULL)
 ,(3,N'Ultima Sincronizacion Log',NULL,NULL,NULL,NULL,NULL,0,NULL)
 ,(4,N'SMVM',NULL,NULL,NULL,NULL,NULL,1,N'Valor para el salario minimo vital y movil')
 ,(5,N'Vencimiento Legajo Riesgo Medio',NULL,NULL,NULL,NULL,NULL,1,N'Cantidad de Años que tarda en vencer el legajo de una persona con riesgo medio')
 ,(6,N'Vencimiento Legajo Riesgo Alto',NULL,NULL,NULL,NULL,NULL,1,N'Cantidad de Años que tarda en vencer el legajo de una persona con riesgo alto')
 ,(7,N'Dias Revalidacion Listas',NULL,NULL,NULL,NULL,NULL,1,N'Parametrización para alerta de relación entre aportes y rescates')
 ,(8,N'Relación aportes rescates',NULL,NULL,NULL,NULL,NULL,1,N'Parametrización para alerta de relación entre aportes y rescates')
 ,(9,N'Tolerancia aportes rescates',NULL,NULL,NULL,NULL,NULL,1,N'Parametrización para alerta de relación entre aportes y rescates')
 ,(10,N'Meses Retencion Tabla Log',NULL,NULL,NULL,NULL,NULL,0,N'Guarda la cantidad de meses que se deben retener os registros en la tabla log procesos')
) AS [Source] ([SettingId],[SettingName],[StringValue],[IntValue],[DecimalValue],[DateTimeValue],[BooleanValue],[Edit],[Description])
ON ([Target].[SettingId] = [Source].[SettingId])
WHEN MATCHED AND (
	NULLIF([Source].[SettingName], [Target].[SettingName]) IS NOT NULL OR NULLIF([Target].[SettingName], [Source].[SettingName]) IS NOT NULL OR 
	NULLIF([Source].[StringValue], [Target].[StringValue]) IS NOT NULL OR NULLIF([Target].[StringValue], [Source].[StringValue]) IS NOT NULL OR 
	NULLIF([Source].[IntValue], [Target].[IntValue]) IS NOT NULL OR NULLIF([Target].[IntValue], [Source].[IntValue]) IS NOT NULL OR 
	NULLIF([Source].[DecimalValue], [Target].[DecimalValue]) IS NOT NULL OR NULLIF([Target].[DecimalValue], [Source].[DecimalValue]) IS NOT NULL OR 
	NULLIF([Source].[DateTimeValue], [Target].[DateTimeValue]) IS NOT NULL OR NULLIF([Target].[DateTimeValue], [Source].[DateTimeValue]) IS NOT NULL OR 
	NULLIF([Source].[BooleanValue], [Target].[BooleanValue]) IS NOT NULL OR NULLIF([Target].[BooleanValue], [Source].[BooleanValue]) IS NOT NULL OR 
	NULLIF([Source].[Edit], [Target].[Edit]) IS NOT NULL OR NULLIF([Target].[Edit], [Source].[Edit]) IS NOT NULL OR 
	NULLIF([Source].[Description], [Target].[Description]) IS NOT NULL OR NULLIF([Target].[Description], [Source].[Description]) IS NOT NULL) THEN
 UPDATE SET
  [SettingName] = [Source].[SettingName], 
  [StringValue] = [Source].[StringValue], 
  [IntValue] = [Source].[IntValue], 
  [DecimalValue] = [Source].[DecimalValue], 
  [DateTimeValue] = [Source].[DateTimeValue], 
  [BooleanValue] = [Source].[BooleanValue], 
  [Edit] = [Source].[Edit], 
  [Description] = [Source].[Description]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([SettingId],[SettingName],[StringValue],[IntValue],[DecimalValue],[DateTimeValue],[BooleanValue],[Edit],[Description])
 VALUES([Source].[SettingId],[Source].[SettingName],[Source].[StringValue],[Source].[IntValue],[Source].[DecimalValue],[Source].[DateTimeValue],[Source].[BooleanValue],[Source].[Edit],[Source].[Description])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
;
GO
DECLARE @mergeError int
 , @mergeCount int
SELECT @mergeError = @@ERROR, @mergeCount = @@ROWCOUNT
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [Setting]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[Setting] rows affected by MERGE: ' + CAST(@mergeCount AS VARCHAR(100));
 END
GO

SET IDENTITY_INSERT [Setting] OFF
GO
SET NOCOUNT OFF
GO

SET NOCOUNT ON

SET IDENTITY_INSERT [Risk] ON

MERGE INTO [Risk] AS [Target]
USING (VALUES
  (1,N'Bajo')
 ,(2,N'Medio')
 ,(3,N'Alto')
) AS [Source] ([RiskId],[Description])
ON ([Target].[RiskId] = [Source].[RiskId])
WHEN MATCHED AND (
	NULLIF([Source].[Description], [Target].[Description]) IS NOT NULL OR NULLIF([Target].[Description], [Source].[Description]) IS NOT NULL) THEN
 UPDATE SET
  [Description] = [Source].[Description]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([RiskId],[Description])
 VALUES([Source].[RiskId],[Source].[Description])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
;
GO
DECLARE @mergeError int
 , @mergeCount int
SELECT @mergeError = @@ERROR, @mergeCount = @@ROWCOUNT
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [Risk]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[Risk] rows affected by MERGE: ' + CAST(@mergeCount AS VARCHAR(100));
 END
GO

SET IDENTITY_INSERT [Risk] OFF
GO
SET NOCOUNT OFF
GO

SET NOCOUNT ON

SET IDENTITY_INSERT [GrayList] ON

MERGE INTO [GrayList] AS [Target]
USING (VALUES
  (1,N'el nuevo chinwen',1,null,null)
) AS [Source] ([GrayListId],[Comments],[Active],[PersonId],[PersonOriginalId])
ON ([Target].[GrayListId] = [Source].[GrayListId])
WHEN MATCHED AND (
	NULLIF(CAST([Source].[Comments] AS VARCHAR(MAX)), CAST([Target].[Comments] AS VARCHAR(MAX))) IS NOT NULL OR NULLIF(CAST([Target].[Comments] AS VARCHAR(MAX)), CAST([Source].[Comments] AS VARCHAR(MAX))) IS NOT NULL OR 
	NULLIF([Source].[Active], [Target].[Active]) IS NOT NULL OR NULLIF([Target].[Active], [Source].[Active]) IS NOT NULL OR 
	NULLIF([Source].[PersonId], [Target].[PersonId]) IS NOT NULL OR NULLIF([Target].[PersonId], [Source].[PersonId]) IS NOT NULL OR 
	NULLIF([Source].[PersonOriginalId], [Target].[PersonOriginalId]) IS NOT NULL OR NULLIF([Target].[PersonOriginalId], [Source].[PersonOriginalId]) IS NOT NULL) THEN
 UPDATE SET
  [Comments] = [Source].[Comments], 
  [Active] = [Source].[Active], 
  [PersonId] = [Source].[PersonId], 
  [PersonOriginalId] = [Source].[PersonOriginalId]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([GrayListId],[Comments],[Active],[PersonId],[PersonOriginalId])
 VALUES([Source].[GrayListId],[Source].[Comments],[Source].[Active],[Source].[PersonId],[Source].[PersonOriginalId])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
;
GO
DECLARE @mergeError int
 , @mergeCount int
SELECT @mergeError = @@ERROR, @mergeCount = @@ROWCOUNT
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [GrayList]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[GrayList] rows affected by MERGE: ' + CAST(@mergeCount AS VARCHAR(100));
 END
GO

SET IDENTITY_INSERT [GrayList] OFF
GO
SET NOCOUNT OFF
GO
SET NOCOUNT ON

SET IDENTITY_INSERT [NewsReasonType] ON

MERGE INTO [NewsReasonType] AS [Target]
USING (VALUES
  (1,N'Otro',1)
 ,(2,N'Analista asignado',1)
 ,(3,N'Reasignado por error',1)
 ,(4,N'Derivado por actitud sospechosa',1)
 ,(5,N'Caso finalizado',1)
 ,(6,N'Falso positivo',1)
 ,(7,N'Caso desestimado',1)
 ,(8,N'Se necesita más tiempo',1)
 ,(9,N'Analista debe continuar',1)
 ,(10,N'Se requiere información más detallada',1)
 ,(11,N'Información recibida',1)
) AS [Source] ([NewsReasonTypeId],[Description],[Global])
ON ([Target].[NewsReasonTypeId] = [Source].[NewsReasonTypeId])
WHEN MATCHED AND (
	NULLIF([Source].[Description], [Target].[Description]) IS NOT NULL OR NULLIF([Target].[Description], [Source].[Description]) IS NOT NULL OR 
	NULLIF([Source].[Global], [Target].[Global]) IS NOT NULL OR NULLIF([Target].[Global], [Source].[Global]) IS NOT NULL) THEN
 UPDATE SET
  [Description] = [Source].[Description], 
  [Global] = [Source].[Global]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([NewsReasonTypeId],[Description],[Global])
 VALUES([Source].[NewsReasonTypeId],[Source].[Description],[Source].[Global])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
;
GO
DECLARE @mergeError int
 , @mergeCount int
SELECT @mergeError = @@ERROR, @mergeCount = @@ROWCOUNT
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [NewsReasonType]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[NewsReasonType] rows affected by MERGE: ' + CAST(@mergeCount AS VARCHAR(100));
 END
GO

SET IDENTITY_INSERT [NewsReasonType] OFF
GO
SET NOCOUNT OFF
GO
GO

SET NOCOUNT ON

SET IDENTITY_INSERT [Number] ON

MERGE INTO [Number] AS [Target]
USING (VALUES
  (1,N'Numero Caso Seguros',N'CaseNumber',N'1',1)
 ,(2,N'Numero Caso Retiro',N'CaseNumber',N'2',1)
 ,(3,N'Numero Caso Iunigo',N'CaseNumber',N'3',1)
) AS [Source] ([NumberId],[Description],[Name],[Token],[Seed])
ON ([Target].[NumberId] = [Source].[NumberId])
WHEN MATCHED AND (
	NULLIF([Source].[Description], [Target].[Description]) IS NOT NULL OR NULLIF([Target].[Description], [Source].[Description]) IS NOT NULL OR 
	NULLIF([Source].[Name], [Target].[Name]) IS NOT NULL OR NULLIF([Target].[Name], [Source].[Name]) IS NOT NULL OR 
	NULLIF([Source].[Token], [Target].[Token]) IS NOT NULL OR NULLIF([Target].[Token], [Source].[Token]) IS NOT NULL OR 
	NULLIF([Source].[Seed], [Target].[Seed]) IS NOT NULL OR NULLIF([Target].[Seed], [Source].[Seed]) IS NOT NULL) THEN
 UPDATE SET
  [Description] = [Source].[Description], 
  [Name] = [Source].[Name], 
  [Token] = [Source].[Token], 
  [Seed] = [Source].[Seed]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([NumberId],[Description],[Name],[Token],[Seed])
 VALUES([Source].[NumberId],[Source].[Description],[Source].[Name],[Source].[Token],[Source].[Seed])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
;
GO
DECLARE @mergeError int
 , @mergeCount int
SELECT @mergeError = @@ERROR, @mergeCount = @@ROWCOUNT
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [Number]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[Number] rows affected by MERGE: ' + CAST(@mergeCount AS VARCHAR(100));
 END
GO

SET IDENTITY_INSERT [Number] OFF
GO
SET NOCOUNT OFF
GO
--Dummies
--:r .\PostDeployment\dbo.Case.sql
--:r .\PostDeployment\dbo.News.sql
--:r .\PostDeployment\dbo.Person.sql
--:r .\PostDeployment\dbo.PersonBusinessUnit.sql
GO

GO
PRINT N'Checking existing data against newly created constraints';


GO
USE [$(DatabaseName)];


GO
ALTER TABLE [dbo].[ActivityRisk] WITH CHECK CHECK CONSTRAINT [FK_ActivityRisk];

ALTER TABLE [dbo].[ActivityRisk] WITH CHECK CHECK CONSTRAINT [FK_ActivityRisk_BusinessUnit];

ALTER TABLE [dbo].[Antiquity] WITH CHECK CHECK CONSTRAINT [FK_Antiquity_BusinessUnit];

ALTER TABLE [dbo].[CaseDocument] WITH CHECK CHECK CONSTRAINT [FK_CaseDocument_Document];

ALTER TABLE [dbo].[CaseDocument] WITH CHECK CHECK CONSTRAINT [FK_CaseDocument_BusinessUnit];

ALTER TABLE [dbo].[CaseType] WITH CHECK CHECK CONSTRAINT [FK_CaseType_CaseGroup];

ALTER TABLE [dbo].[CaseVehicle] WITH CHECK CHECK CONSTRAINT [FK_CaseVehicle_BusinessUnit];

ALTER TABLE [dbo].[ChannelRisk] WITH CHECK CHECK CONSTRAINT [FK_ChannelRisk_BusinessUnit];

ALTER TABLE [dbo].[ChannelRisk] WITH CHECK CHECK CONSTRAINT [FK_ChannelRisk_Channel];

ALTER TABLE [dbo].[ChannelRisk] WITH CHECK CHECK CONSTRAINT [FK_ChannelRisk_Risk];

ALTER TABLE [dbo].[Document] WITH CHECK CHECK CONSTRAINT [FK_Document_DocumentType];

ALTER TABLE [dbo].[Document] WITH CHECK CHECK CONSTRAINT [FK_Document_Person];

ALTER TABLE [dbo].[Document] WITH CHECK CHECK CONSTRAINT [FK_Document_PersonOriginal];

ALTER TABLE [dbo].[DocumentVersion] WITH CHECK CHECK CONSTRAINT [FK_DocumentVersion_Document];

ALTER TABLE [dbo].[FinancialProfilesDefault] WITH CHECK CHECK CONSTRAINT [FK_FinancialProfilesDefault_BusinessUnit];

ALTER TABLE [dbo].[FinancialProfilesDefaultLog] WITH CHECK CHECK CONSTRAINT [FK_FinancialProfilesDefaultLog_BusinessUnit];

ALTER TABLE [dbo].[GrayList] WITH CHECK CHECK CONSTRAINT [FK_GrayList_PersonOriginal];

ALTER TABLE [dbo].[GrayList] WITH CHECK CHECK CONSTRAINT [FK_GrayList_Person];

ALTER TABLE [dbo].[GrayListDocument] WITH CHECK CHECK CONSTRAINT [FK_GrayListDocument_GrayList];

ALTER TABLE [dbo].[GrayListDocument] WITH CHECK CHECK CONSTRAINT [FK_GrayListDocument_Document];

ALTER TABLE [dbo].[LimitAccumulatedClaimsCharged] WITH CHECK CHECK CONSTRAINT [FK_LimitAccumulatedClaimsCharged_BusinessUnit];

ALTER TABLE [dbo].[LimitAccumulatedPremium] WITH CHECK CHECK CONSTRAINT [FK_LimitAccumulatedPremium_BusinessUnit];

ALTER TABLE [dbo].[LimitAssuredSum] WITH CHECK CHECK CONSTRAINT [FK_LimitAssuredSum_Product];

ALTER TABLE [dbo].[LimitAssuredSum] WITH CHECK CHECK CONSTRAINT [FK_LimitAssuredSum_BusinessUnit];

ALTER TABLE [dbo].[LimitRefund] WITH CHECK CHECK CONSTRAINT [FK_LimitRefund_BusinessUnit];

ALTER TABLE [dbo].[Location] WITH CHECK CHECK CONSTRAINT [FK_Location_State];

ALTER TABLE [dbo].[LocationRisk] WITH CHECK CHECK CONSTRAINT [FK_LocationRisk_Location];

ALTER TABLE [dbo].[LocationRisk] WITH CHECK CHECK CONSTRAINT [FK_LocationRisk_BusinessUnit];

ALTER TABLE [dbo].[LocationRisk] WITH CHECK CHECK CONSTRAINT [FK_LocationRisk_Risk];

ALTER TABLE [dbo].[News] WITH CHECK CHECK CONSTRAINT [FK_News_Status];

ALTER TABLE [dbo].[News] WITH CHECK CHECK CONSTRAINT [FK_News_NewsType];

ALTER TABLE [dbo].[News] WITH CHECK CHECK CONSTRAINT [FK_News_NewsReasonType];

ALTER TABLE [dbo].[News] WITH CHECK CHECK CONSTRAINT [FK_News_BusinessUnit];

ALTER TABLE [dbo].[NewsDocument] WITH CHECK CHECK CONSTRAINT [FK_NewsDocument_News];

ALTER TABLE [dbo].[NewsDocument] WITH CHECK CHECK CONSTRAINT [FK_NewsDocument_DocumentLetterType];

ALTER TABLE [dbo].[NewsDocument] WITH CHECK CHECK CONSTRAINT [FK_NewsDocument_Location];

ALTER TABLE [dbo].[NewsMail] WITH CHECK CHECK CONSTRAINT [FK_NewsMail_News];

ALTER TABLE [dbo].[NewsMail] WITH CHECK CHECK CONSTRAINT [FK_NewsMail_MailType];

ALTER TABLE [dbo].[NewsMail] WITH CHECK CHECK CONSTRAINT [FK_NewsMail_BusinessUnit];

ALTER TABLE [dbo].[NewsReason] WITH CHECK CHECK CONSTRAINT [FK_NewsReason];

ALTER TABLE [dbo].[NewsReason] WITH CHECK CHECK CONSTRAINT [FK_NewsReason_NewsReasonType];

ALTER TABLE [dbo].[NewsRiskChange] WITH CHECK CHECK CONSTRAINT [FK_NewsRiskChange_News];

ALTER TABLE [dbo].[NewsRiskChange] WITH CHECK CHECK CONSTRAINT [FK_NewsRiskChange_BusinessUnit];

ALTER TABLE [dbo].[OperatedVolume] WITH CHECK CHECK CONSTRAINT [FK_OperatedVolume_BusinessUnit];

ALTER TABLE [dbo].[PaymentModeRisk] WITH CHECK CHECK CONSTRAINT [FK_PaymentModeRisk_PaymentMode];

ALTER TABLE [dbo].[PaymentModeRisk] WITH CHECK CHECK CONSTRAINT [FK_PaymentModeRisk_BusinessUnit];

ALTER TABLE [dbo].[PaymentModeRisk] WITH CHECK CHECK CONSTRAINT [FK_PaymentModeRisk_Risk];

ALTER TABLE [dbo].[Person] WITH CHECK CHECK CONSTRAINT [FK_Person_Activity];

ALTER TABLE [dbo].[Person] WITH CHECK CHECK CONSTRAINT [FK_Person_Location];

ALTER TABLE [dbo].[Person] WITH CHECK CHECK CONSTRAINT [FK_Person_BusinessUnit];

ALTER TABLE [dbo].[PersonBusinessUnit] WITH CHECK CHECK CONSTRAINT [FK_PersonBusinessUnit_Person];

ALTER TABLE [dbo].[PersonBusinessUnit] WITH CHECK CHECK CONSTRAINT [FK_PersonBusinessUnit_BusinessUnit];

ALTER TABLE [dbo].[PersonBusinessUnit] WITH CHECK CHECK CONSTRAINT [FK_PersonBusinessUnit_Risk];

ALTER TABLE [dbo].[PersonWareHouse] WITH CHECK CHECK CONSTRAINT [FK_PersonWareHouse_Activity];

ALTER TABLE [dbo].[PolicyType] WITH CHECK CHECK CONSTRAINT [FK_PolicyType_Branch];

ALTER TABLE [dbo].[ProcessesLog] WITH CHECK CHECK CONSTRAINT [FK_ProcessesLog_Processes];

ALTER TABLE [dbo].[ProcessesLog] WITH CHECK CHECK CONSTRAINT [FK_ProcessesLog_MessageType];

ALTER TABLE [dbo].[ProcessesLog] WITH CHECK CHECK CONSTRAINT [FK_ProcessesLog_BusinessUnit];

ALTER TABLE [dbo].[ProcessesRisk] WITH CHECK CHECK CONSTRAINT [FK_ProcessesRisk_Product];

ALTER TABLE [dbo].[ProcessesRisk] WITH CHECK CHECK CONSTRAINT [FK_ProcessesRisk_BusinessUnit];

ALTER TABLE [dbo].[ProcessesRisk] WITH CHECK CHECK CONSTRAINT [FK_ProcessesRisk_Risk];

ALTER TABLE [dbo].[Producer] WITH CHECK CHECK CONSTRAINT [FK_Producer_BusinessUnit];

ALTER TABLE [dbo].[RiskAssignmentRanges] WITH CHECK CHECK CONSTRAINT [FK_RiskAssignmentRanges_BusinessUnit];

ALTER TABLE [dbo].[RiskAssignmentRangesLog] WITH CHECK CHECK CONSTRAINT [FK_RiskAssignmentRangesLog_BusinessUnit];

ALTER TABLE [dbo].[State] WITH CHECK CHECK CONSTRAINT [FK_State_Country];

ALTER TABLE [fwk].[Table] WITH CHECK CHECK CONSTRAINT [CK01_fwk_Table];

ALTER TABLE [dbo].[Case] WITH CHECK CHECK CONSTRAINT [FK_Case_CaseType];

ALTER TABLE [dbo].[Case] WITH CHECK CHECK CONSTRAINT [FK_Case_BranchOffice];

ALTER TABLE [dbo].[Case] WITH CHECK CHECK CONSTRAINT [FK_Case_Person];

ALTER TABLE [dbo].[Case] WITH CHECK CHECK CONSTRAINT [FK_Case_Producer];

ALTER TABLE [dbo].[Case] WITH CHECK CHECK CONSTRAINT [FK_Case_Status];

ALTER TABLE [dbo].[Case] WITH CHECK CHECK CONSTRAINT [FK_Case_OriginalPerson];

ALTER TABLE [dbo].[Case] WITH CHECK CHECK CONSTRAINT [FK_Case_BusinessUnit];

ALTER TABLE [dbo].[Case] WITH CHECK CHECK CONSTRAINT [FK_Case_Risk];

ALTER TABLE [dbo].[CaseDocument] WITH CHECK CHECK CONSTRAINT [FK_CaseDocument_Case];

ALTER TABLE [dbo].[CaseVehicle] WITH CHECK CHECK CONSTRAINT [FK_CaseVehicle_Case];

ALTER TABLE [dbo].[News] WITH CHECK CHECK CONSTRAINT [FK_News_Cases];


GO
PRINT N'Update complete.';


GO
